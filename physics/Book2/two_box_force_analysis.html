
<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç‰©ç†åŠ›å­¸æ¨¡æ“¬ï¼šé€£æ¥é«”ç³»çµ±</title>
    <!-- å¼•å…¥ MathJax é€²è¡Œ LaTeX æ¸²æŸ“ -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        /* åŸºç¤è¨­å®š */
        :root {
            --primary-color: #3498db;
            --secondary-color: #2c3e50;
            --accent-color: #e74c3c;
            --bg-color: #ecf0f1;
            --text-color: #333;
        }

        body {
            font-family: "Microsoft JhengHei", "Heiti TC", sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            color: var(--secondary-color);
            margin-bottom: 5px;
            font-weight: 900;
        }

        .subtitle {
            color: #7f8c8d;
            margin-bottom: 25px;
            font-size: 1.1em;
            font-weight: 500;
        }

        /* ç•«å¸ƒå®¹å™¨ */
        .canvas-container {
            position: relative;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            overflow: hidden;
            margin-bottom: 20px;
            border: 1px solid #ddd;
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        /* æ‡¸æµ®æç¤º */
        .hover-hint {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.95em;
            color: #444;
            border-left: 5px solid var(--accent-color);
            pointer-events: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            font-weight: bold;
        }

        /* æ§åˆ¶é¢æ¿ */
        .controls-panel {
            background: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.05);
            width: 100%;
            max-width: 850px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 25px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        label {
            font-weight: bold;
            font-size: 1em;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* å¼·åˆ¶ span å…§çš„æ–‡å­—ä¸æ›è¡Œ */
        label span {
            white-space: nowrap;
            color: var(--primary-color);
        }

        input[type="range"] {
            width: 100%;
            accent-color: var(--primary-color);
            cursor: pointer;
        }

        /* æ•¸æ“šé¡¯ç¤ºå€ */
        .data-display {
            grid-column: 1 / -1;
            display: flex;
            justify-content: space-around;
            align-items: center;
            background-color: var(--secondary-color);
            color: white;
            padding: 18px;
            border-radius: 10px;
            margin-bottom: 15px;
            font-family: "Microsoft JhengHei", monospace;
            font-size: 1.2em;
            flex-wrap: wrap;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.2);
        }

        .data-item {
            margin: 5px 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .data-value {
            font-family: monospace;
            font-weight: bold;
            color: #f1c40f;
            min-width: 60px;
            text-align: right;
        }

        /* æŒ‰éˆ•ç¾¤çµ„ */
        .btn-group {
            grid-column: 1 / -1;
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 15px;
        }

        button {
            padding: 12px 30px;
            border: none;
            border-radius: 30px;
            font-size: 1.05em;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.2s, background-color 0.2s;
            box-shadow: 0 3px 0 rgba(0,0,0,0.1);
        }

        button:active {
            transform: translateY(2px);
            box-shadow: none;
        }

        .btn-combine {
            background-color: var(--accent-color);
            color: white;
        }
        
        .btn-combine:hover { background-color: #c0392b; }

        .btn-explain {
            background-color: var(--primary-color);
            color: white;
        }
        
        .btn-explain:hover { background-color: #2980b9; }

        /* å½ˆå‡ºè¦–çª— (Modal) */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            z-index: 2000;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(4px);
        }

        .modal-content {
            background: white;
            width: 90%;
            max-width: 650px;
            padding: 35px;
            border-radius: 15px;
            position: relative;
            animation: slideUp 0.35s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        }

        @keyframes slideUp {
            from { transform: translateY(30px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .close-btn {
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 28px;
            cursor: pointer;
            color: #aaa;
            transition: color 0.2s;
        }
        
        .close-btn:hover { color: #333; }

        .physics-note {
            background-color: #fff8e1;
            border-left: 5px solid #ffc107;
            padding: 15px;
            border-radius: 4px;
            margin-top: 20px;
            font-size: 1em;
            line-height: 1.6;
        }

        .label-text {
            color: #555555; /* Gray for the label name */
        }

        h2 { color: var(--secondary-color); margin-top: 0; }
        h3 { color: var(--primary-color); border-bottom: 2px solid #eee; padding-bottom: 8px; margin-top: 25px;}
        p, li { line-height: 1.6; font-size: 1.05em; }

        /* æ•¸å­¸å…¬å¼å¾®èª¿ */
        mjx-container { font-size: 1.1em !important; }

    </style>
</head>
<body>

    <h1>ç‰©ç†åŠ›å­¸å¯¦é©—å®¤ï¼šé€£æ¥é«”åˆ†æ</h1>
    <div class="subtitle">æ¨¡æ“¬æƒ…å¢ƒï¼šå…‰æ»‘å¹³é¢ä¸Šï¼Œå…©å€‹ç‰©é«”è¢«å‘å·¦çš„åŠ›æ‹‰å‹•</div>

    <div class="canvas-container">
        <canvas id="simCanvas" width="900" height="450"></canvas>
        <div class="hover-hint">ğŸ’¡ è€å¸«æç¤ºï¼šå°‡æ»‘é¼ ç§»å‹•åˆ°ç‰©é«”ä¸Šæ–¹ï¼Œå³å¯æŸ¥çœ‹è©³ç´°çš„ã€Œéš”é›¢é«”å—åŠ›åœ– (FBD)ã€</div>
    </div>

    <div class="controls-panel">
        
        <!-- æ•¸æ“šå„€è¡¨æ¿ -->
        <div class="data-display">
            <div class="data-item">åŠ é€Ÿåº¦ \( a \): <span id="valAcc" class="data-value">0.00</span> \( m/s^2 \)</div>
            <div class="data-item" id="tensionDisplay">ç¹©å¼µåŠ› \( T \): <span id="valTension" class="data-value">0.00</span> N</div>
            <div class="data-item">æ‘©æ“¦åŠ›ç¸½å’Œ \( f_{ç¸½} \): <span id="valFriction" class="data-value">0.00</span> N</div>
        </div>

        <!-- æ»‘æ¡¿æ§åˆ¶ -->
        <div class="control-group">
            <label>ç‰©é«” A è³ªé‡ (å·¦) <span id="txtM1">5 kg</span></label>
            <input type="range" id="slM1" min="1" max="20" value="5" step="0.5">
        </div>

        <div class="control-group">
            <label>ç‰©é«” B è³ªé‡ (å³) <span id="txtM2">3 kg</span></label>
            <input type="range" id="slM2" min="1" max="20" value="3" step="0.5">
        </div>

        <div class="control-group">
            <label>
                <span class="label-text">å‘å·¦æ‹‰åŠ› \( F \)</span> 
                <span id="txtF">50 N</span>
            </label>
            <input type="range" id="slF" min="0" max="70" value="25" step="1">
        </div>

        <div class="control-group">
            <label>
                <span class="label-text">å‹•æ‘©æ“¦ä¿‚æ•¸ \( \mu \) </span>
                <span id="txtMu">0.2</span>
            </label>
            <input type="range" id="slMu" min="0" max="0.8" value="0.2" step="0.05">
        </div>

        <!-- æŒ‰éˆ• -->
        <div class="btn-group">
            <button class="btn-combine" id="btnCombine" onclick="toggleMode()">åˆ‡æ›æ¨¡å¼ï¼šåˆé«” (System)</button>
            <button class="btn-explain" onclick="showModal()">ğŸ“– è€å¸«è¬›è§£åŸç†</button>
        </div>
    </div>

    <!-- å½ˆå‡ºæ•™å­¸è¦–çª— -->
    <div class="modal-overlay" id="helpModal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeModal()">&times;</span>
            <h2>ğŸ‘¨â€ğŸ« è€å¸«çš„ç‰©ç†ç­†è¨˜</h2>
            <hr style="border: 0; border-top: 1px solid #eee; margin: 15px 0;">
            
            <h3>1. ç‚ºä½•è¦æœ‰ã€Œåˆé«”æ¨¡å¼ã€ï¼Ÿ</h3>
            <p>ç•¶æˆ‘å€‘å°‡ A å’Œ B è¦–ç‚ºä¸€å€‹<strong>æ•´é«”ç³»çµ±</strong>æ™‚ï¼š</p>
            <ul>
                <li>ç¹©å­çš„å¼µåŠ› \( T \) è®Šæˆç³»çµ±çš„<strong>å…§åŠ›</strong>ã€‚</li>
                <li>æ ¹æ“šç‰›é “ç¬¬ä¸‰å®šå¾‹ï¼Œå…§åŠ›äº’ç›¸æŠµéŠ·ï¼Œæ‰€ä»¥åœ¨è¨ˆç®—åŠ é€Ÿåº¦ \( a \) æ™‚ä¸éœ€è¦è€ƒæ…® \( T \)ã€‚</li>
                <li>ç³»çµ±æ–¹ç¨‹ï¼š $$ F - f_{ç¸½} = (m_A + m_B)a $$</li>
            </ul>

            <h3>2. æ€æ¨£æ‰¾å›å¼µåŠ› \( T \)ï¼Ÿ</h3>
            <p>é¡Œç›®å¦‚æœå•å¼µåŠ›ï¼Œæˆ‘å€‘å¿…é ˆé—œæ³¨åœ¨<strong> å…¶ä¸­ä¸€å€‹ </strong>ç‰©é«”ï¼Œåˆ‡æ–·ç¹©å­ä¾†çœ‹ï¼š</p>
            <ul>
                <li>åªçœ‹ç‰©é«” B (å³é‚Šé‚£å€‹)ï¼šå®ƒå‘å·¦è¢«ç¹©æ‹‰ (\( T \))ï¼Œå‘å³è¢«åœ°æ‘©æ“¦ (\( f_B \))ã€‚</li>
                <li>ç‰©é«” B åŠ›å­¸å…¬å¼ï¼š$$ T - f_B = m_B a $$</li>
            </ul>

            <div class="physics-note">
                <strong>ğŸ’¡ æ‘©æ“¦å°çŸ¥è­˜ï¼š</strong><br>
                å¦‚æœæ‹‰åŠ›å¤ªå°æ‹‰ä¸å‹•ï¼Œæ‘©æ“¦åŠ›ä¸æœƒæ˜¯ \(\mu N\)ï¼Œè€Œæ˜¯ç­‰æ–¼å¤–åŠ›ï¼ˆå› ç‚ºåˆåŠ›ç‚º0ï¼‰ã€‚<br>
                ä¾‹å¦‚ï¼šä½ ç”¨ 10N åŠ›æ¨ä¸€å€‹é‡ç®±å­ï¼Œç®±å­ä¸å‹•ï¼Œæ‘©æ“¦åŠ›å°±æ˜¯ 10Nï¼Œè€Œä¸æ˜¯æœ€å¤§æ‘©æ“¦åŠ›ã€‚
            </div>
            <br>
            <button class="btn-explain" style="width:100%" onclick="closeModal()">æ˜ç™½äº†ï¼Œé–‹å§‹å¯¦é©—ï¼</button>
        </div>
    </div>

<script>
    /**
     * ç‰©ç†æ¨¡æ“¬æ ¸å¿ƒé‚è¼¯
     */
    
    // Canvas è¨­å®š
    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d');
    
    // é¡è‰²å®šç¾©
    const COLORS = {
        force: '#e74c3c',    // ç´… (æ‹‰åŠ›)
        tension: '#d35400',  // æ©™ (å¼µåŠ›)
        friction: '#2980b9', // è— (æ‘©æ“¦åŠ›) - å·²æ›´æ”¹
        normal: '#27ae60',   // ç¶  (æ­£å‘åŠ›)
        gravity: '#34495e',  // æ·±ç°/é»‘ (é‡åŠ›)
        blockA: '#3498db',
        blockB: '#e74c3c',
        blockCombined: '#9b59b6'
    };
    
    // è‡ªå‹•å½ˆå‡ºåŸç†è¦–çª—
    setTimeout(() => showModal(true), 800);
    
    // ç‹€æ…‹è®Šæ•¸
    let state = {
        m1: 5,      // å·¦é‚Šç‰©é«”è³ªé‡ (kg)
        m2: 3,      // å³é‚Šç‰©é«”è³ªé‡ (kg)
        F: 25,      // å‘å·¦æ‹‰åŠ› (N)
        mu: 0.2,    // æ‘©æ“¦ä¿‚æ•¸
        g: 9.81,    // é‡åŠ›åŠ é€Ÿåº¦
        isCombined: false, // åˆé«”æ¨¡å¼
        time: 0,    // å‹•ç•«æ™‚é–“
        animSpeed: 0, // åœ°æ¿ç§»å‹•é€Ÿåº¦
        isMoving: false
    };
    
    // è¨ˆç®—çµæœ
    let physics = {
        a: 0,       // åŠ é€Ÿåº¦
        T: 0,       // å¼µåŠ›
        f1: 0,      // m1 å¯¦éš›æ‘©æ“¦åŠ›
        f2: 0,      // m2 å¯¦éš›æ‘©æ“¦åŠ›
        N1: 0,      // m1 æ­£å‘åŠ›
        N2: 0       // m2 æ­£å‘åŠ›
    };

    // äº’å‹•ç›¸é—œ
    let mouse = { x: 0, y: 0 };
    let hoveredObject = null; // 'm1', 'm2', 'combined' or null

    // DOM å…ƒç´ å¼•ç”¨
    const els = {
        slM1: document.getElementById('slM1'),
        slM2: document.getElementById('slM2'),
        slF: document.getElementById('slF'),
        slMu: document.getElementById('slMu'),
        txtM1: document.getElementById('txtM1'),
        txtM2: document.getElementById('txtM2'),
        txtF: document.getElementById('txtF'),
        txtMu: document.getElementById('txtMu'),
        valAcc: document.getElementById('valAcc'),
        valTension: document.getElementById('valTension'),
        valFriction: document.getElementById('valFriction'),
        tensionDisplay: document.getElementById('tensionDisplay'),
        btnCombine: document.getElementById('btnCombine')
    };

    // åˆå§‹åŒ–äº‹ä»¶ç›£è½
    function init() {
        // æ»‘æ¡¿ç›£è½
        els.slM1.addEventListener('input', updateParams);
        els.slM2.addEventListener('input', updateParams);
        els.slF.addEventListener('input', updateParams);
        els.slMu.addEventListener('input', updateParams);

        // æ»‘é¼ ç›£è½
        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
        });

        // å•Ÿå‹•å¾ªç’°
        updateParams();
        requestAnimationFrame(loop);
    }

    function updateParams() {
        state.m1 = parseFloat(els.slM1.value);
        state.m2 = parseFloat(els.slM2.value);
        state.F = parseFloat(els.slF.value);
        state.mu = parseFloat(els.slMu.value);

        // æ›´æ–°æ–‡å­—é¡¯ç¤º
        els.txtM1.textContent = `${state.m1} kg`;
        els.txtM2.textContent = `${state.m2} kg`;
        els.txtF.textContent = `${state.F} N`;
        els.txtMu.textContent = `${state.mu}`;

        calculatePhysics();
    }

    function calculatePhysics() {
        const totalMass = state.m1 + state.m2;
        
        // 1. è¨ˆç®—æ­£å‘åŠ›
        physics.N1 = state.m1 * state.g;
        physics.N2 = state.m2 * state.g;

        // 2. è¨ˆç®—æœ€å¤§éœæ‘©æ“¦åŠ› (Limiting Friction)
        const f1_max = state.mu * physics.N1;
        const f2_max = state.mu * physics.N2;
        const f_total_max = f1_max + f2_max;

        // 3. åˆ¤æ–·é‹å‹•ç‹€æ…‹
        // å¦‚æœæ‹‰åŠ›å¤§æ–¼æœ€å¤§ç¸½æ‘©æ“¦åŠ›ï¼Œç³»çµ±æ‰æœƒå‹•
        if (state.F > f_total_max) {
            // --- å‹•æ…‹ (Kinetic) ---
            state.isMoving = true;
            physics.f1 = f1_max;
            physics.f2 = f2_max;
            
            const F_net = state.F - (physics.f1 + physics.f2);
            physics.a = F_net / totalMass;
            
            physics.T = (state.m2 * physics.a) + physics.f2;

        } else {
            // --- éœæ…‹ (Static) ---
            state.isMoving = false;
            physics.a = 0;
            
            if (state.F <= f1_max) {
                physics.f1 = state.F; 
                physics.T = 0;        
                physics.f2 = 0;       
            } 
            else {
                physics.f1 = f1_max;           
                physics.T = state.F - f1_max;  
                physics.f2 = physics.T;        
            }
        }

        const f_total_actual = physics.f1 + physics.f2;

        // ä»‹é¢æ›´æ–°
        els.valAcc.textContent = physics.a.toFixed(2);
        els.valTension.textContent = physics.T.toFixed(2);
        els.valFriction.textContent = f_total_actual.toFixed(2);

        // å‹•ç•«é€Ÿåº¦
        state.animSpeed = physics.a / 4; 
    }

    // ç¹ªåœ–å¾ªç’°
    function loop() {
        ctx.font = '16px "Microsoft JhengHei", Arial, sans-serif';
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // å®šç¾©åœ°é¢é«˜åº¦
        const floorY = canvas.height - 100;

        // ç¹ªè£½èƒŒæ™¯ (åœ°æ¿)
        drawFloor(floorY);

        // å®šç¾©ç‰©é«”ä½ç½® (å±…ä¸­)
        const centerX = canvas.width / 2;
        const size1 = Math.min(100, Math.max(50, 40 + state.m1 * 3));
        const size2 = Math.min(100, Math.max(50, 40 + state.m2 * 3));
        const gap = 180;
        const stringY = floorY - 30; // ç¹©å­é«˜åº¦å›ºå®š

        // ç‰©é«”å®šç¾©
        let obj1 = { 
            x: centerX - gap/2 - size1, y: floorY - size1, w: size1, h: size1, 
            color: COLORS.blockA, label: 'A', mass: state.m1 
        };
        let obj2 = { 
            x: centerX + gap/2, y: floorY - size2, w: size2, h: size2, 
            color: COLORS.blockB, label: 'B', mass: state.m2 
        };
        
        // é‡ç½® Hover ç‹€æ…‹
        hoveredObject = null;

        if (state.isCombined) {
            // --- åˆé«”æ¨¡å¼ ---
            const totalW = size1 + size2;
            const maxHeight = Math.max(size1, size2);
            const combineX = centerX - totalW/2;
            const combineY = floorY - maxHeight;
            
            drawBlock(combineX, combineY, totalW, maxHeight, COLORS.blockCombined, 'A+B', state.m1 + state.m2);
            
            // éœæ­¢è­¦å‘Š
            if (!state.isMoving && state.F > 0) {
                drawStaticWarning(combineX, combineY, totalW, maxHeight, floorY);
            }
            
            // æª¢æŸ¥ Hover
            checkHover(combineX, combineY, totalW, maxHeight, 'combined');
            
            // åªæœ‰ç•¶æ²’æœ‰ Hover åœ¨åˆé«”ä¸Šæ™‚ï¼Œæ‰ç•«ä¸»è¦–åœ–çš„æ‹‰åŠ›
            if (hoveredObject !== 'combined') {
                drawForceArrow(combineX, combineY + maxHeight/2, state.F/7*12+20, 'left', 'F', COLORS.force);
            }

            drawForceArrow(combineX + totalW/2, floorY, (physics.f1 + physics.f2)/7*12+20, 'right', 'f_total', COLORS.friction);

            
            if (hoveredObject === 'combined') {
                drawFBD_Combined(combineX + totalW/2, combineY + maxHeight/2, totalW, maxHeight);
            }

        } else {
            // --- åˆ†é«”æ¨¡å¼ ---
            
            // ç¹©å­
            ctx.beginPath();
            ctx.moveTo(obj1.x + obj1.w, stringY);
            ctx.lineTo(obj2.x, stringY);
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 4;
            ctx.stroke();

            // ç‰©é«”
            drawBlock(obj1.x, obj1.y, obj1.w, obj1.h, obj1.color, obj1.label, obj1.mass);
            drawBlock(obj2.x, obj2.y, obj2.w, obj2.h, obj2.color, obj2.label, obj2.mass);

            // éœæ­¢è­¦å‘Š
            if (!state.isMoving && state.F > 0) {
                drawStaticWarning(obj1.x, obj1.y, obj1.w, obj1.h, floorY, true);
                drawStaticWarning(obj2.x, obj2.y, obj2.w, obj2.h, floorY, false);
            }

            // æª¢æŸ¥ Hover
            if (isMouseOver(obj1)) hoveredObject = 'm1';
            else if (isMouseOver(obj2)) hoveredObject = 'm2';

            // åªæœ‰ç•¶æ²’æœ‰ Hover åœ¨ m1 ä¸Šæ™‚ï¼Œæ‰ç•«ä¸»è¦–åœ–çš„æ‹‰åŠ›
            if (hoveredObject !== 'm1') {
                drawForceArrow(obj1.x, obj1.y+obj1.h/2, state.F/7*12+20, 'left', 'F', COLORS.force);
            }

            // FBD é¡¯ç¤º
            if (hoveredObject === 'm1') {
                highlightBlock(obj1);
                drawFBD_M1(obj1.x + obj1.w/2, obj1.y + obj1.h/2, obj1.w, obj1.h);
            } else if (hoveredObject === 'm2') {
                highlightBlock(obj2);
                drawFBD_M2(obj2.x + obj2.w/2, obj2.y + obj2.h/2, obj2.w, obj2.h);
            }
        }

        if (state.isMoving) {
            state.time += state.animSpeed;
        }

        requestAnimationFrame(loop);
    }

    // --- ç¹ªåœ–å‡½æ•¸ ---

    function drawBlock(x, y, w, h, color, label, mass) {
        ctx.fillStyle = color;
        ctx.fillRect(x, y, w, h);
        ctx.strokeStyle = '#34495e';
        ctx.lineWidth = 3;
        ctx.strokeRect(x, y, w, h);
        
        ctx.fillStyle = 'white';
        ctx.font = 'bold 24px "Microsoft JhengHei", Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(label, x + w/2, y + h/2);
        
        ctx.fillStyle = '#2c3e50';
        ctx.font = 'bold 16px "Microsoft JhengHei", Arial';
        ctx.fillText(`${mass} kg`, x + w/2, y - 12);
    }

    function drawStaticWarning(x, y, w, h, floorY, skipText = false) {
        ctx.strokeStyle = '#c0392b';
        ctx.lineWidth = 4;
        ctx.setLineDash([8, 6]);
        ctx.strokeRect(x-5, y-5, w+10, h+10);
        ctx.setLineDash([]);
        
        if (!skipText) {
            ctx.fillStyle = '#c0392b';
            ctx.font = 'bold 22px "Microsoft JhengHei", Arial';
            ctx.textAlign = 'center';
            ctx.fillText("âš ï¸ æ‘©æ“¦å¹³è¡¡", canvas.width/2, floorY + 45);
        }
    }

    function highlightBlock(obj) {
        ctx.strokeStyle = '#f1c40f';
        ctx.lineWidth = 5;
        ctx.strokeRect(obj.x - 2, obj.y - 2, obj.w + 4, obj.h + 4);
    }

    function drawFloor(y) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.strokeStyle = '#95a5a6';
        ctx.lineWidth = 3;
        ctx.stroke();

        const offset = state.time % 40;
        ctx.beginPath();
        for (let i = -40; i < canvas.width; i += 40) {
            let x = i + offset; 
            ctx.moveTo(x, y);
            ctx.lineTo(x - 15, y + 15);
        }
        ctx.strokeStyle = '#bdc3c7';
        ctx.lineWidth = 2;
        ctx.stroke();
    }

    function drawForceArrow(x, y, magnitude, direction, label, color) {
        if (magnitude <= 20) return; 

        const maxLen = 140; 
        const scale = 1.0; 
        let len = Math.min(magnitude * scale, maxLen);

        ctx.beginPath();
        ctx.lineWidth = 4;
        ctx.lineCap = "round";
        ctx.strokeStyle = color;
        ctx.fillStyle = color;

        let endX = x;
        let endY = y;
        let labelAlign = 'center';
        let labelX = x;
        let labelY = y;
        
        ctx.font = 'bold 18px "Microsoft JhengHei", Arial';

        if (direction === 'left') {
            endX = x - len;
            drawStylishArrowHead(ctx, x, y, endX, endY);
            labelAlign = 'right';
            labelX = endX + 20;
            labelY = y - 15;
        } else if (direction === 'right') {
            endX = x + len;
            drawStylishArrowHead(ctx, x, y, endX, endY);
            labelAlign = 'left';
            labelX = endX - 20;
            labelY = y - 15;
        } else if (direction === 'up') {
            endY = y - len;
            drawStylishArrowHead(ctx, x, y, endX, endY);
            labelAlign = 'center';
            labelX = x;
            labelY = endY - 10;
        } else if (direction === 'down') {
            endY = y + len;
            drawStylishArrowHead(ctx, x, y, endX, endY);
            labelAlign = 'center';
            labelX = x - 22;
            labelY = y + magnitude/2;
        }
        
        drawLabelWithSubscript(ctx, label, labelX, labelY, labelAlign);
    }
    
    // ç¹ªè£½å¸¶æœ‰ä¸‹æ¨™çš„æ¨™ç±¤
    function drawLabelWithSubscript(ctx, text, x, y, align) {
        ctx.textAlign = align;
        ctx.textBaseline = 'middle';
        
        // ç°¡å–®è§£æï¼šç”¨ "_" åˆ†éš”ä¸»æ–‡æœ¬å’Œä¸‹æ¨™
        let parts = text.split('_');
        let mainText = parts[0];
        let subText = parts.length > 1 ? parts[1] : "";
        
        // å¦‚æœåŒ…å« "="ï¼Œæˆ‘å€‘éœ€è¦è™•ç†æ•¸å€¼éƒ¨åˆ†ï¼Œä¸æ‡‰æŠŠæ•¸å€¼ç•¶ä½œä¸‹æ¨™
        // å‡è¨­æ ¼å¼æ˜¯ "f_total = 10N" -> main: f, sub: total, remainder: " = 10N"
        // ç°¡å–®èµ·è¦‹ï¼Œé€™è£¡æ‰‹å‹•è™•ç†ç‰¹å®šæ¨™ç±¤
        
        if (text.startsWith("f_tot")) {
            mainText = "f";
            subText = "total";
            // è™•ç†æ•¸å€¼éƒ¨åˆ†
            let valPart = text.substring(text.indexOf("="));
            if (valPart && valPart.length > 1) {
                // ç¹ªè£½
                let mainWidth = ctx.measureText(mainText).width;
                ctx.fillText(mainText, x, y);
                
                // ä¸‹æ¨™
                ctx.font = 'bold 12px "Microsoft JhengHei", Arial';
                let subX = x + (align === 'right' ? -ctx.measureText(valPart).width : mainWidth);
                if (align === 'center') subX = x + mainWidth/2;
                if (align === 'right') subX = x - ctx.measureText(valPart).width - ctx.measureText(subText).width;
                
                // é€™è£¡å¤ªè¤‡é›œï¼Œç”¨æ›´ç°¡å–®çš„æ–¹æ³•ï¼šç›´æ¥æŒ‰é †åºç•«
                // å› ç‚º align ä¸åŒï¼Œè¨ˆç®—èµ·é»æ¯”è¼ƒéº»ç…©
                // è®“æˆ‘å€‘åˆ‡æ›å›ç°¡å–®æ¨¡å¼ï¼šåªè™•ç† "f_total", "N_tot" ç­‰æ¨™ç±¤ï¼Œæ•¸å€¼ç›´æ¥è·Ÿåœ¨å¾Œé¢
            }
        }
        
        // é‡æ–°å¯¦ä½œä¸€å€‹é€šç”¨çš„å·¦å°é½Šç¹ªè£½å‡½æ•¸ï¼Œç„¶å¾Œæ ¹æ“š align èª¿æ•´èµ·å§‹ x
        // é€™éœ€è¦è¨ˆç®—ç¸½å¯¬åº¦
        
        // åˆ†è§£å­—ä¸²
        let components = []; // {text, isSub, font}
        let currentFont = 'bold 18px "Microsoft JhengHei", Arial';
        let subFont = 'bold 13px "Microsoft JhengHei", Arial';
        
        // è™•ç†å¸¸è¦‹æ¨¡å¼
        if (text.includes("_")) {
            let split1 = text.split(" = ");
            let lhs = split1[0]; // å·¦é‚Šç¬¦è™Ÿ (e.g. f_total)
            let rhs = split1.length > 1 ? " = " + split1[1] : ""; // å³é‚Šæ•¸å€¼ (e.g. = 50 N)
            
            let lhsParts = lhs.split("_");
            components.push({text: lhsParts[0], isSub: false});
            if (lhsParts[1]) components.push({text: lhsParts[1], isSub: true});
            if (rhs) components.push({text: rhs, isSub: false});
        } else {
            components.push({text: text, isSub: false});
        }
        
        // è¨ˆç®—ç¸½å¯¬åº¦
        let totalWidth = 0;
        components.forEach(c => {
            ctx.font = c.isSub ? subFont : currentFont;
            c.width = ctx.measureText(c.text).width;
            totalWidth += c.width;
        });
        
        // æ±ºå®šèµ·å§‹ X
        let startX = x;
        if (align === 'center') startX = x - totalWidth / 2;
        else if (align === 'right') startX = x - totalWidth;
        
        // ç¹ªè£½
        let cursorX = startX;
        components.forEach(c => {
            ctx.font = c.isSub ? subFont : currentFont;
            // ä¸‹æ¨™å‘ä¸‹åç§»
            let offY = c.isSub ? 5 : 0; 
            ctx.textAlign = 'left'; // å¼·åˆ¶å·¦å°é½Šä»¥ä¾¿æ’ç‰ˆ
            ctx.fillText(c.text, cursorX, y + offY);
            cursorX += c.width;
        });
        
        // æ¢å¾©å­—é«”
        ctx.font = currentFont;
    }

    function drawStylishArrowHead(ctx, fromX, fromY, toX, toY) {
        const headlen = 15; 
        const dx = toX - fromX;
        const dy = toY - fromY;
        const angle = Math.atan2(dy, dx);
        
        // è¨ˆç®—ç®­é ­èƒŒéƒ¨çš„ä¸­å¿ƒé»ï¼Œè®“ç·šèº«åœåœ¨é€™è£¡ï¼Œè€Œä¸æ˜¯ç©¿éå°–ç«¯
        // ç®­é ­æ˜¯å¯¦å¿ƒçš„ï¼Œæˆ‘å€‘è®“ç·šåœåœ¨ç®­é ­åº•éƒ¨ç¨å¾®é€²å»ä¸€é»çš„åœ°æ–¹ï¼Œç¢ºä¿é€£æ¥ç·Šå¯†ä½†ä¸å‡ºé ­
        const backX = toX - headlen * Math.cos(angle);
        const backY = toY - headlen * Math.sin(angle);

        // ç•«ç·šèº« (åªç•«åˆ°ç®­é ­èƒŒéƒ¨)
        ctx.moveTo(fromX, fromY);
        ctx.lineTo(backX, backY);
        ctx.stroke();
        
        // ç•«å¯¦å¿ƒç®­é ­
        ctx.beginPath();
        ctx.moveTo(toX, toY);
        ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 7), toY - headlen * Math.sin(angle - Math.PI / 7));
        ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 7), toY - headlen * Math.sin(angle + Math.PI / 7));
        ctx.lineTo(toX, toY);
        ctx.fill(); 
    }

    // --- FBD ç¹ªåœ– ---

    function drawFBD_M1(cx, cy, w, h) {
        drawOverlayBase(cx, cy, "A (å·¦)");
        
        drawForceArrow(cx - w/2, cy, state.F/7*12+20, 'left', `F = ${state.F} N`, COLORS.force);
        drawForceArrow(cx + w/2, cy+h/2-30, physics.T/7*12+20, 'right', `T = ${physics.T.toFixed(2)} N`, COLORS.tension);
        drawForceArrow(cx, cy + h/2, physics.f1/7*12+20, 'right', `f = ${physics.f1.toFixed(2)} N`, COLORS.friction);
        
        drawForceArrow(cx+h/20, cy + h/2, physics.N1/20*10+20, 'up', 'N', COLORS.normal);
        drawForceArrow(cx, cy, (state.m1 * state.g)/20*10+20, 'down', 'mg', COLORS.gravity);
    }

    function drawFBD_M2(cx, cy, w, h) {
        drawOverlayBase(cx, cy, "B (å³)");
        
        drawForceArrow(cx - w/2, cy+h/2-30, physics.T/7*12+20, 'left', `T = ${physics.T.toFixed(2)} N`, COLORS.tension);
        drawForceArrow(cx, cy + h/2, physics.f2/7*12+20, 'right', `f = ${physics.f2.toFixed(2)} N`, COLORS.friction);
        
        drawForceArrow(cx+h/20, cy + h/2, physics.N2/20*10+20, 'up', 'N', COLORS.normal);
        drawForceArrow(cx, cy, state.m2 * state.g /20*10+20, 'down', 'mg', COLORS.gravity);
    }

    function drawFBD_Combined(cx, cy, w, h) {
        drawOverlayBase(cx, cy, "ç³»çµ± (A+B)");
        
        drawForceArrow(cx - w/2, cy, state.F/7*12+20, 'left', `F = ${state.F} N`, COLORS.force);
        drawForceArrow(cx, cy + h/2, (physics.f1 + physics.f2)/7*12+20, 'right', `f_total = ${(physics.f1+physics.f2).toFixed(2)} N`, COLORS.friction);
        
        drawForceArrow(cx+h/20, cy + h/2, (physics.N1+physics.N2)/20*10+20, 'up', 'N_total', COLORS.normal);
        drawForceArrow(cx, cy, (state.m1+state.m2)*state.g /20*10+20, 'down', 'Mg', COLORS.gravity);
    }

    function drawOverlayBase(x, y, title) {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.beginPath();
        ctx.arc(x, y, 130, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = '#bdc3c7';
        ctx.lineWidth = 1;
        ctx.stroke();
    }

    // --- è¼”åŠ©é‚è¼¯ ---

    function isMouseOver(obj) {
        return mouse.x > obj.x && mouse.x < obj.x + obj.w &&
               mouse.y > obj.y && mouse.y < obj.y + obj.h;
    }

    function checkHover(x, y, w, h, id) {
        if (mouse.x > x && mouse.x < x + w && mouse.y > y && mouse.y < y + h) {
            hoveredObject = id;
        }
    }

    function toggleMode() {
        state.isCombined = !state.isCombined;
        if (state.isCombined) {
            els.btnCombine.textContent = "åˆ‡æ›æ¨¡å¼ï¼šåˆ†é«” (Isolated)";
            els.btnCombine.style.backgroundColor = "#9b59b6";
            els.tensionDisplay.style.opacity = "0.4";
        } else {
            els.btnCombine.textContent = "åˆ‡æ›æ¨¡å¼ï¼šåˆé«” (System)";
            els.btnCombine.style.backgroundColor = "#e74c3c";
            els.tensionDisplay.style.opacity = "1";
        }
    }

    function showModal() {
        document.getElementById('helpModal').style.display = 'flex';
    }

    function closeModal() {
        document.getElementById('helpModal').style.display = 'none';
    }

    window.onclick = function(event) {
        const modal = document.getElementById('helpModal');
        if (event.target == modal) {
            modal.style.display = "none";
        }
    }
    
    init();

</script>

</body>
</html>



