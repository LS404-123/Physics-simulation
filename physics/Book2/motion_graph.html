<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DSE ç‰©ç†æ¨¡æ“¬ï¼šé‹å‹•åœ–åƒé—œä¿‚ (Kinematic Graphs)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@300;400;700&display=swap');
        body { font-family: 'Noto Sans TC', sans-serif; }
        
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #888; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }

        .graph-container {
            position: relative;
            /* Reduced height to fit better */
            height: 30%; 
            width: 100%;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            margin-bottom: 8px;
            overflow: hidden;
        }
        
        .axis-label {
            position: absolute;
            font-size: 10px;
            color: #6b7280;
            pointer-events: none;
        }

        .modal {
            transition: opacity 0.25s ease;
        }
        .modal-hidden {
            opacity: 0;
            pointer-events: none;
        }
        .modal-visible {
            opacity: 1;
            pointer-events: auto;
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-800 h-screen flex flex-col overflow-hidden">

    <!-- Navbar -->
    <nav class="bg-blue-600 text-white p-3 shadow-md flex justify-between items-center z-10 shrink-0">
        <div class="flex items-center gap-2">
            <span class="text-xl font-bold">ğŸ§ª ç‰©ç†å¯¦é©—å®¤ï¼šé‹å‹•åœ–åƒ (Kinematics)</span>
            <span class="text-xs bg-blue-500 px-2 py-1 rounded border border-blue-400">DSE ç‰©ç†ç§‘</span>
        </div>
        <button onclick="toggleInfo()" class="bg-white text-blue-600 px-3 py-1 rounded font-bold hover:bg-blue-50 text-sm transition">
            ğŸ“– è€å¸«ç­†è¨˜ (Teacher's Note)
        </button>
    </nav>

    <!-- Main Content -->
    <div class="flex flex-1 overflow-hidden">
        
        <!-- Left: Simulation View & Controls -->
        <div class="w-1/2 flex flex-col border-r border-slate-200 bg-white p-4 relative">
            
            <!-- Canvas Simulation -->
            <div class="relative w-full h-1/2 bg-slate-100 rounded-xl border border-slate-300 overflow-hidden shadow-inner mb-4 flex justify-center items-end" id="sim-container">
                <canvas id="simCanvas" class="w-full h-full block"></canvas>
                
                <!-- Dynamic Data Overlay -->
                <div class="absolute top-2 left-2 bg-white/90 p-2 rounded shadow text-xs font-mono space-y-1">
                    <div class="text-blue-600 font-bold">t = <span id="val-t">0.00</span> s</div>
                    <div class="text-indigo-600">s = <span id="val-s">0.00</span> m</div>
                    <div class="text-emerald-600">v = <span id="val-v">0.00</span> m sâ»Â¹</div>
                    <div class="text-rose-600">a = <span id="val-a">0.00</span> m sâ»Â²</div>
                </div>

                <!-- Ruler/Ground Visuals -->
                <div class="absolute bottom-0 w-full h-4 bg-slate-300 border-t border-slate-400"></div>
            </div>

            <!-- Controls Panel -->
            <div class="flex-1 overflow-y-auto pr-2">
                <div class="bg-slate-50 p-4 rounded-xl border border-slate-200 space-y-4">
                    
                    <!-- Scenario Buttons -->
                    <div>
                        <h3 class="text-sm font-bold text-slate-500 mb-2 uppercase tracking-wide">é¸æ“‡æƒ…å¢ƒ (Scenario)</h3>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-2">
                            <button onclick="setScenario(1)" class="scenario-btn p-2 rounded bg-white border hover:bg-blue-50 hover:border-blue-300 text-sm font-medium transition text-left" id="btn-sc1">
                                ğŸš— æ†å®šåŠ é€Ÿåº¦<br><span class="text-xs text-slate-500">Constant Acceleration</span>
                            </button>
                            <button onclick="setScenario(2)" class="scenario-btn p-2 rounded bg-white border hover:bg-blue-50 hover:border-blue-300 text-sm font-medium transition text-left" id="btn-sc2">
                                ğŸ¾ å‚ç›´ä¸Šæ‹‹<br><span class="text-xs text-slate-500">Vertical Toss</span>
                            </button>
                            <button onclick="setScenario(3)" class="scenario-btn p-2 rounded bg-white border hover:bg-blue-50 hover:border-blue-300 text-sm font-medium transition text-left" id="btn-sc3">
                                ğŸ€ å½ˆè·³çƒ<br><span class="text-xs text-slate-500">Bouncing Ball</span>
                            </button>
                        </div>
                    </div>

                    <!-- Playback Controls -->
                    <div class="flex flex-wrap gap-4 items-center bg-white p-3 rounded border border-slate-200">
                        <button onclick="togglePlay()" id="playBtn" class="bg-blue-600 hover:bg-blue-700 text-white w-10 h-10 rounded-full flex items-center justify-center transition shadow">
                            <svg id="icon-play" class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 3l14 9-14 9V3z"></path></svg>
                            <svg id="icon-pause" class="w-4 h-4 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                        </button>
                        <button onclick="resetSim()" class="text-slate-600 hover:text-red-500 font-medium text-sm px-3 py-1">
                            é‡ç½® (Reset)
                        </button>
                        
                        <div class="flex-1 min-w-[120px]">
                            <label class="text-xs text-slate-500 font-bold block mb-1">æ¨¡æ“¬é€Ÿåº¦ (Speed)</label>
                            <input type="range" id="speedRange" min="0.1" max="0.6" step="0.1" value="0.3" class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600">
                            <div class="flex justify-between text-[10px] text-slate-400"><span>æ…¢ (Slow)</span><span>å¿« (Fast)</span></div>
                        </div>
                    </div>

                    <!-- Hints Box -->
                    <div class="bg-yellow-50 border border-yellow-200 p-3 rounded text-sm text-yellow-800">
                        <strong class="block mb-1">ğŸ’¡ è§€å¯Ÿé‡é»ï¼š</strong>
                        <p id="hint-text">è«‹é¸æ“‡ä¸€å€‹æƒ…å¢ƒé–‹å§‹ã€‚</p>
                    </div>

                </div>
            </div>
        </div>

        <!-- Right: Graphs Panel -->
        <div class="w-1/2 bg-slate-50 p-4 overflow-y-auto flex flex-col gap-2">
            <h3 class="text-sm font-bold text-slate-500 mb-1 uppercase text-center">å¯¦æ™‚é‹å‹•åœ–åƒ (Real-time Graphs)</h3>

            <!-- S-T Graph -->
            <div class="graph-container">
                <canvas id="graphS" class="w-full h-full"></canvas>
                <div class="axis-label top-2 left-11 font-bold text-indigo-600">s (m) ä½ç§»</div>
            </div>
            
            <!-- V-T Graph -->
            <div class="graph-container">
                <canvas id="graphV" class="w-full h-full"></canvas>
                <div class="axis-label top-2 left-11 font-bold text-emerald-600">v (m sâ»Â¹) é€Ÿåº¦</div>
                <!-- Legend for Area -->
                <div class="absolute top-2 right-2 text-[10px] flex items-center gap-1 bg-white/80 p-1 rounded">
                    <div class="w-3 h-3 bg-emerald-200 border border-emerald-400"></div>
                    <span>é¢ç© = ä½ç§»</span>
                </div>
            </div>

            <!-- A-T Graph -->
            <div class="graph-container">
                <canvas id="graphA" class="w-full h-full"></canvas>
                <div class="axis-label top-2 left-11 font-bold text-rose-600">a (m sâ»Â²) åŠ é€Ÿåº¦</div>
            </div>

            <div class="text-xs text-slate-400 text-center mt-2">
                *æ³¨æ„ï¼šæ‰€æœ‰åœ–åƒå‡æ¡ç”¨å›ºå®šåæ¨™æ¯”ä¾‹ï¼Œä»¥ä¾¿æ¯”è¼ƒã€‚å¿½ç•¥ç©ºæ°£é˜»åŠ›ã€‚
            </div>
        </div>

    </div>

    <!-- Modal: Teacher's Note -->
    <div id="infoModal" class="fixed inset-0 bg-black/50 z-50 flex items-center justify-center modal-hidden">
        <div class="bg-white w-full max-w-2xl rounded-xl shadow-2xl overflow-hidden m-4 flex flex-col max-h-[90vh]">
            <div class="bg-blue-600 p-4 flex justify-between items-center text-white">
                <h2 class="text-lg font-bold">ğŸ“š è€å¸«ç­†è¨˜ï¼šåœ–åƒé—œä¿‚ç¸½çµ</h2>
                <button onclick="toggleInfo()" class="hover:bg-blue-700 rounded p-1">âœ•</button>
            </div>
            <div class="p-6 overflow-y-auto text-slate-700 space-y-4">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div class="bg-blue-50 p-4 rounded-lg border border-blue-100">
                        <h3 class="font-bold text-blue-800 mb-2">1. æ–œç‡çš„æ„ç¾©</h3>
                        <ul class="list-disc pl-5 text-sm space-y-1">
                            <li><b class="text-indigo-600">s-t åœ–</b>çš„æ–œç‡ = <b class="text-emerald-600">é€Ÿåº¦ (v)</b></li>
                            <li><b class="text-emerald-600">v-t åœ–</b>çš„æ–œç‡ = <b class="text-rose-600">åŠ é€Ÿåº¦ (a)</b></li>
                            <li>å¦‚æœæ–œç‡æ˜¯æ­£æ•¸ï¼Œä»£è¡¨æ­£æ–¹å‘ï¼›è² æ•¸å‰‡ä»£è¡¨åæ–¹å‘ã€‚</li>
                            <li>æ›²ç·šçš„æ–œç‡ä»£è¡¨ã€Œç¬æ™‚ã€æ•¸å€¼ã€‚</li>
                        </ul>
                    </div>
                    <div class="bg-emerald-50 p-4 rounded-lg border border-emerald-100">
                        <h3 class="font-bold text-emerald-800 mb-2">2. é¢ç©çš„æ„ç¾©</h3>
                        <ul class="list-disc pl-5 text-sm space-y-1">
                            <li><b class="text-rose-600">a-t åœ–</b>ä¸‹çš„é¢ç© = <b class="text-emerald-600">é€Ÿåº¦çš„è®ŠåŒ– (Î”v)</b></li>
                            <li><b class="text-emerald-600">v-t åœ–</b>ä¸‹çš„é¢ç© = <b class="text-indigo-600">ä½ç§» (Î”s)</b></li>
                            <li>æ³¨æ„ï¼šæ™‚é–“è»¸ä¸‹æ–¹çš„é¢ç©ä»£è¡¨ã€Œè² ä½ç§»ã€ï¼Œè¨ˆç®—ç¸½ä½ç§»æ™‚éœ€è¦è€ƒæ…®æ­£è² è™Ÿäº’ç›¸æŠµæ¶ˆã€‚</li>
                        </ul>
                    </div>
                </div>
                
                <div class="border-t pt-4 mt-2">
                    <h3 class="font-bold text-gray-800 mb-2">é‡å°å ´æ™¯çš„æç¤ºï¼š</h3>
                    <ul class="text-sm space-y-2">
                        <li><strong>ğŸš— æ†å®šåŠ é€Ÿåº¦ï¼š</strong> s - t åœ–æ˜¯æ‹‹ç‰©ç·šï¼Œv - t æ˜¯ç›´ç·šï¼Œa - t æ˜¯æ°´å¹³ç·šã€‚ç•™æ„ s éš¨ t<sup>2</sup> å¢åŠ ã€‚</li>
                        <li><strong>ğŸ¾ å‚ç›´ä¸Šæ‹‹ï¼š</strong> æœ€é«˜é»æ™‚ï¼Œé€Ÿåº¦ v = 0ï¼Œä½†åŠ é€Ÿåº¦ä»ç„¶æ˜¯ a = -9.8 ms<sup>-2</sup> (ä¸æœƒè®Šæˆ0!)ã€‚v - t åœ–æ˜¯ä¸€æ¢ç©¿é x è»¸çš„ç›´ç·šã€‚</li>
                        <li><strong>ğŸ€ å½ˆè·³çƒï¼š</strong> ç¢°æ’åœ°é¢æ™‚ï¼Œé€Ÿåº¦æœƒåœ¨æ¥µçŸ­æ™‚é–“å…§ç”±è² è®Šæ­£ã€‚åœ¨ v - t åœ–ä¸Šæœƒçœ‹åˆ°å¹¾ä¹å‚ç›´çš„ç·šã€‚ä½ç§»æ°¸é ä¸æœƒå°æ–¼ 0ã€‚</li>
                    </ul>
                </div>
            </div>
            <div class="bg-gray-50 p-4 border-t flex justify-end">
                <button onclick="toggleInfo()" class="bg-blue-600 text-white px-6 py-2 rounded hover:bg-blue-700 transition">æ˜ç™½äº†</button>
            </div>
        </div>
    </div>

    <script>
        // --- Constants & Global State ---
        const CANVAS_WIDTH_RATIO = 2; // For high DPI
        
        setTimeout(() => toggleInfo(true), 500);
        
        let simState = {
            t: 0,
            s: 0,
            v: 0,
            a: 0,
            dt: 0.016, // Base time step (16ms)
            speedMultiplier: 1.0,
            scenario: 1,
            running: false,
            history: [], // Stores {t, s, v, a}
            maxHistoryTime: 10, // Keep last 10 seconds in graph
            groundY: 0, // Will be set based on canvas
            simWidth: 0 // Width of sim canvas in logical pixels
        };

        // DOM Elements
        const simCanvas = document.getElementById('simCanvas');
        const ctxSim = simCanvas.getContext('2d');
        const graphs = {
            s: document.getElementById('graphS'),
            v: document.getElementById('graphV'),
            a: document.getElementById('graphA')
        };
        const ctxs = {
            s: graphs.s.getContext('2d'),
            v: graphs.v.getContext('2d'),
            a: graphs.a.getContext('2d')
        };

        // --- Initialization ---

        function resizeCanvases() {
            // Resize Sim Canvas
            const container = document.getElementById('sim-container');
            simCanvas.width = container.clientWidth * CANVAS_WIDTH_RATIO;
            simCanvas.height = container.clientHeight * CANVAS_WIDTH_RATIO;
            ctxSim.scale(CANVAS_WIDTH_RATIO, CANVAS_WIDTH_RATIO);
            
            simState.simWidth = container.clientWidth;
            simState.groundY = container.clientHeight - 20; // 20px padding from bottom

            // Resize Graphs
            Object.values(graphs).forEach(canvas => {
                const parent = canvas.parentElement;
                canvas.width = parent.clientWidth * CANVAS_WIDTH_RATIO;
                canvas.height = parent.clientHeight * CANVAS_WIDTH_RATIO;
                // We don't scale context here, we handle scaling in draw function for precision
            });
            
            draw(); // Redraw immediately
        }

        window.addEventListener('resize', resizeCanvases);

        function init() {
            resizeCanvases();
            setScenario(1);
            loop();
        }

        // --- Physics Logic ---

        function updatePhysics() {
            if (!simState.running) return;

            // Apply time dilation
            const dt = simState.dt * simState.speedMultiplier;
            simState.t += dt;

            // Physics scenarios
            if (simState.scenario === 1) { 
                // Constant Acceleration (Car)
                // a = 2, v = u + at
                simState.a = 2.0;
                simState.v += simState.a * dt;
                simState.s += simState.v * dt;

                // Stop at right border
                // px = 20 + simState.s * 20
                // Max Px allowed = simState.simWidth - 20 (padding)
                // (simState.simWidth - 40) = simState.s * 20
                const maxS = (simState.simWidth - 40) / 20;
                
                if (simState.s >= maxS) {
                    simState.s = maxS;
                    simState.running = false;
                    document.getElementById('icon-play').classList.remove('hidden');
                    document.getElementById('icon-pause').classList.add('hidden');
                }

            } else if (simState.scenario === 2) {
                // Vertical Toss
                // a = -9.8
                simState.a = -9.8;
                simState.v += simState.a * dt;
                simState.s += simState.v * dt;
                
                // Stop if hits ground
                if (simState.s < 0) {
                    simState.s = 0;
                    simState.running = false;
                    document.getElementById('icon-play').classList.remove('hidden');
                    document.getElementById('icon-pause').classList.add('hidden');
                }

            } else if (simState.scenario === 3) {
                // Bouncing Ball
                simState.a = -9.8;
                simState.v += simState.a * dt;
                simState.s += simState.v * dt;

                // Collision Detection
                if (simState.s <= 0 && simState.v < 0) {
                    simState.s = 0;
                    simState.v = -simState.v * 0.80; 
                    
                    if (Math.abs(simState.v) < 5) {
                        simState.v = 0;
                        simState.s = 0;
                        simState.running = false;
                        document.getElementById('icon-play').classList.remove('hidden');
                        document.getElementById('icon-pause').classList.add('hidden');
                    }
                }
            }

            // Record History
            simState.history.push({
                t: simState.t,
                s: simState.s,
                v: simState.v,
                a: simState.a
            });

            if (simState.history.length > 5000) {
                simState.history.shift();
            }

            updateUIValues();
        }

        function updateUIValues() {
            document.getElementById('val-t').textContent = simState.t.toFixed(2);
            document.getElementById('val-s').textContent = simState.s.toFixed(2);
            document.getElementById('val-v').textContent = simState.v.toFixed(2);
            document.getElementById('val-a').textContent = simState.a.toFixed(2);
        }

        // --- Rendering ---

        function drawSim() {
            const w = simCanvas.width / CANVAS_WIDTH_RATIO;
            const h = simCanvas.height / CANVAS_WIDTH_RATIO;
            
            ctxSim.clearRect(0, 0, w, h);

            // Ground
            ctxSim.beginPath();
            ctxSim.moveTo(0, simState.groundY);
            ctxSim.lineTo(w, simState.groundY);
            ctxSim.strokeStyle = '#94a3b8';
            ctxSim.stroke();

            // Object
            let px = 0, py = 0;
            const scaleP = 50; // pixels per meter for Vertical

            if (simState.scenario === 1) {
                // Horizontal motion
                // s is x-position
                px = 20 + simState.s * 20; // scale 20px per meter
                py = simState.groundY - 20; // radius 20
                
                // Draw Car/Ball
                ctxSim.fillStyle = '#3b82f6';
                ctxSim.beginPath();
                ctxSim.arc(px, py, 15, 0, Math.PI * 2);
                ctxSim.fill();
                
                // Draw wheels
                ctxSim.fillStyle = '#1e293b';
                ctxSim.beginPath();
                ctxSim.arc(px - 10, py + 15, 5, 0, Math.PI * 2);
                ctxSim.arc(px + 10, py + 15, 5, 0, Math.PI * 2);
                ctxSim.fill();

                // Speed lines
                if (simState.v > 0) {
                    ctxSim.strokeStyle = '#bfdbfe';
                    ctxSim.lineWidth = 2;
                    ctxSim.beginPath();
                    ctxSim.moveTo(px - 25, py - 5);
                    ctxSim.lineTo(px - 40, py - 5);
                    ctxSim.moveTo(px - 25, py + 5);
                    ctxSim.lineTo(px - 35, py + 5);
                    ctxSim.stroke();
                }

            } else {
                // Vertical motion (Scenario 2 & 3)
                px = w / 2;
                py = simState.groundY - 15 - (simState.s * scaleP); // 1m = 50px

                // Ball
                ctxSim.fillStyle = '#ef4444'; // Red for ball
                if (simState.scenario === 3) ctxSim.fillStyle = '#f59e0b'; // Orange for basketball

                ctxSim.beginPath();
                ctxSim.arc(px, py, 15, 0, Math.PI * 2);
                ctxSim.fill();
                
                // Shine
                ctxSim.fillStyle = 'rgba(255,255,255,0.3)';
                ctxSim.beginPath();
                ctxSim.arc(px - 5, py - 5, 5, 0, Math.PI * 2);
                ctxSim.fill();
            }
        }

        function drawGraph(type, canvas, ctx, color, fillColor) {
            const w = canvas.width;
            const h = canvas.height;
            // Clear entire canvas including high DPI area
            ctx.clearRect(0, 0, w, h);

            if (simState.history.length === 0 && !simState.running && simState.t === 0) {
               // Render axes even if empty
            }

            // Graph Settings (Pixel coordinates are scaled by CANVAS_WIDTH_RATIO in the logic manually or via scale)
            // Wait, we didn't scale context for graphs. So we must use raw pixels or scale.
            // Let's rely on raw pixels calculation for crisp text.
            const ratio = CANVAS_WIDTH_RATIO;
            
            const paddingLeft = 35 * ratio;
            const paddingBottom = 20 * ratio;
            const paddingTop = 10 * ratio;
            const paddingRight = 10 * ratio;

            const graphH = h - paddingBottom - paddingTop;
            const graphW = w - paddingLeft - paddingRight;

            // Calculate Ranges (Rolling Window)
            const timeWindow = 10; 
            let tEnd = Math.max(simState.t, timeWindow);
            let tStart = tEnd - timeWindow;
            
            let yMin, yMax, yStep;
            
            if (simState.scenario === 1) {
                // Const Accel
                if (type === 's') { yMin = -2; yMax = 35; yStep = 5; }
                if (type === 'v') { yMin = -5; yMax = 15; yStep = 5; }
                if (type === 'a') { yMin = -1; yMax = 5; yStep = 1; }
            } else if (simState.scenario === 2) {
                // Toss
                if (type === 's') { yMin = -2; yMax = 15; yStep = 5; }
                if (type === 'v') { yMin = -20; yMax = 20; yStep = 10; }
                if (type === 'a') { yMin = -15; yMax = 5; yStep = 5; }
            } else {
                // Bounce
                if (type === 's') { yMin = -2; yMax = 15; yStep = 5; }
                if (type === 'v') { yMin = -20; yMax = 20; yStep = 10; }
                if (type === 'a') { yMin = -15; yMax = 15; yStep = 5; }
            }

            // Draw Axes
            ctx.strokeStyle = '#cbd5e1';
            ctx.lineWidth = 1 * ratio;
            ctx.beginPath();
            
            // Y Axis Line
            const x0 = paddingLeft;
            ctx.moveTo(x0, paddingTop);
            ctx.lineTo(x0, h - paddingBottom);
            
            // X Axis Line (at Y=0 value if possible, else bottom)
            // Actually usually physics graphs show X-axis at Y=0.
            const zeroYRatio = (0 - yMin) / (yMax - yMin);
            // If zero is within range [0, 1], draw horizontal line there
            let y0Px = (h - paddingBottom) - zeroYRatio * graphH;
            
            // Clamp Y0 to graph area for visual boundary
            if (y0Px > h - paddingBottom) y0Px = h - paddingBottom;
            if (y0Px < paddingTop) y0Px = paddingTop;

            ctx.moveTo(x0, y0Px);
            ctx.lineTo(w - paddingRight, y0Px);
            ctx.stroke();
            
            // Draw X Axis Label (t/s) dynamically following the line
            ctx.fillStyle = '#6b7280';
            ctx.font = `${10 * ratio}px sans-serif`;
            ctx.textAlign = 'right';
            ctx.textBaseline = 'bottom';
            // Position it at the end of the line, slightly above the line
            ctx.fillText("t (s)", w - paddingRight, y0Px - 2 * ratio);

            // --- Ticks & Labels ---
            ctx.fillStyle = '#64748b';
            ctx.font = `${10 * ratio}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';

            // X Axis Ticks (Time)
            const tStep = 2; // Every 2 seconds
            const firstT = Math.ceil(tStart / tStep) * tStep;
            for (let t = firstT; t <= tEnd; t += tStep) {
                if (t < tStart) continue;
                const tx = x0 + ((t - tStart) / timeWindow) * graphW;
                
                // Tick
                ctx.beginPath();
                ctx.moveTo(tx, y0Px);
                ctx.lineTo(tx, y0Px + 5 * ratio);
                ctx.strokeStyle = '#cbd5e1';
                ctx.stroke();

                // Label
                ctx.fillText(t.toString(), tx, h - paddingBottom + 4 * ratio);
            }

            // Y Axis Ticks (Value)
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            
            // Helper function
            const mapY = (val) => (h - paddingBottom) - ((val - yMin) / (yMax - yMin)) * graphH;

            for (let val = Math.ceil(yMin/yStep)*yStep; val <= yMax; val += yStep) {
                const ty = mapY(val);
                // Tick
                ctx.beginPath();
                ctx.moveTo(x0, ty);
                ctx.lineTo(x0 - 5 * ratio, ty);
                ctx.strokeStyle = '#cbd5e1';
                ctx.stroke();

                // Label
                ctx.fillText(val.toString(), x0 - 8 * ratio, ty);
            }


            // --- Draw Data ---
            // Helper function to map data to pixels
            const mapX = (t) => x0 + ((t - tStart) / timeWindow) * graphW;

            if (simState.history.length === 0) return;

            ctx.lineWidth = 2 * ratio;
            ctx.strokeStyle = color;
            ctx.lineJoin = 'round';
            
            ctx.beginPath();
            let first = true;

            // Optimization
            let startIndex = 0;
            for(let i=0; i<simState.history.length; i++) {
                if(simState.history[i].t >= tStart) {
                    startIndex = i;
                    break;
                }
            }

            // Fill Area for V-T
            if (type === 'v' && fillColor) {
                let pStart = simState.history[startIndex];
                if(pStart) {
                    ctx.moveTo(mapX(pStart.t), mapY(0));
                    for (let i = startIndex; i < simState.history.length; i++) {
                        const p = simState.history[i];
                        ctx.lineTo(mapX(p.t), mapY(p[type]));
                    }
                    let pLast = simState.history[simState.history.length-1];
                    ctx.lineTo(mapX(pLast.t), mapY(0));
                    ctx.fillStyle = fillColor;
                    ctx.fill();
                    ctx.beginPath(); // Reset for stroke
                }
            }

            for (let i = startIndex; i < simState.history.length; i++) {
                const p = simState.history[i];
                const px = mapX(p.t);
                const py = mapY(p[type]);
                
                // Vertical line for bounce discontinuity
                if (i > 0 && type === 'v' && Math.abs(p.v - simState.history[i-1].v) > 5) {
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(mapX(p.t), mapY(simState.history[i-1].v));
                    ctx.lineTo(px, py);
                    ctx.stroke();
                    ctx.beginPath();
                }

                if (first) {
                    ctx.moveTo(px, py);
                    first = false;
                } else {
                    ctx.lineTo(px, py);
                }
            }
            ctx.stroke();

            // Draw Head Dot
            const last = simState.history[simState.history.length - 1];
            const cx = mapX(last.t);
            const cy = mapY(last[type]);
            
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(cx, cy, 3 * ratio, 0, Math.PI * 2);
            ctx.fill();
        }

        function draw() {
            drawSim();
            // Draw Graphs (S: Blue, V: Green, A: Red)
            drawGraph('s', graphs.s, ctxs.s, '#4f46e5'); 
            drawGraph('v', graphs.v, ctxs.v, '#059669', 'rgba(167, 243, 208, 0.4)'); 
            drawGraph('a', graphs.a, ctxs.a, '#e11d48'); 
            requestAnimationFrame(loop);
        }

        function loop() {
            updatePhysics();
            draw();
        }

        // --- Interaction ---

        function togglePlay() {
            simState.running = !simState.running;
            document.getElementById('icon-play').classList.toggle('hidden', simState.running);
            document.getElementById('icon-pause').classList.toggle('hidden', !simState.running);
        }

        function resetSim() {
            simState.running = false;
            simState.t = 0;
            simState.history = [];
            document.getElementById('icon-play').classList.remove('hidden');
            document.getElementById('icon-pause').classList.add('hidden');
            
            // Reset Init Conditions
            if (simState.scenario === 1) {
                simState.s = 0;
                simState.v = 0;
                simState.a = 2;
            } else if (simState.scenario === 2) {
                simState.s = 0;
                simState.v = 14; 
                simState.a = -9.8;
            } else {
                simState.s = 10;
                simState.v = 0;
                simState.a = -9.8;
            }
            updateUIValues();
            // Force redraw to clear graphs
            draw();
        }

        function setScenario(id) {
            simState.scenario = id;
            document.querySelectorAll('.scenario-btn').forEach(b => b.classList.remove('bg-blue-100', 'border-blue-500', 'ring-2', 'ring-blue-200'));
            document.getElementById(`btn-sc${id}`).classList.add('bg-blue-100', 'border-blue-500', 'ring-2', 'ring-blue-200');
            
            const hints = {
                1: "æ±½è»Šå¾éœæ­¢é–‹å§‹ï¼Œä»¥æ†å®šåŠ é€Ÿåº¦åŠ é€Ÿã€‚ç•™æ„ s-t åœ–æ˜¯å¦å‘ˆç¾æ›²ç·šï¼Ÿv-t åœ–æ˜¯å¦ç‚ºç›´ç·šï¼Ÿç•¶è»Šåˆ°é”é‚Šç•Œæ™‚æœƒåœæ­¢ã€‚",
                2: "å°çƒä»¥ 20 m/s å‘ä¸Šæ‹‹å‡ºã€‚è§€å¯Ÿæœ€é«˜é»æ™‚ï¼ˆv=0ï¼‰ï¼ŒåŠ é€Ÿåº¦æ˜¯å¤šå°‘ï¼Ÿç•™æ„ v-t ç·šç©¿é x è»¸çš„æ™‚åˆ»ã€‚",
                3: "ç±ƒçƒè‡ªç”±è½ä¸‹ä¸¦åå½ˆã€‚æ³¨æ„åå½ˆç¬é–“ï¼Œé€Ÿåº¦åœ–å½¢æœƒå‡ºç¾å‚ç›´çš„è·³è®Šï¼ˆç”±è² æ¥µé€Ÿè®Šç‚ºæ­£æ¥µé€Ÿï¼‰ã€‚"
            };
            document.getElementById('hint-text').innerText = hints[id];

            resetSim();
        }

        function toggleInfo() {
            const m = document.getElementById('infoModal');
            if (m.classList.contains('modal-hidden')) {
                m.classList.remove('modal-hidden');
                m.classList.add('modal-visible');
            } else {
                m.classList.remove('modal-visible');
                m.classList.add('modal-hidden');
            }
        }

        document.getElementById('speedRange').addEventListener('input', (e) => {
            simState.speedMultiplier = parseFloat(e.target.value);
        });

        init();

    </script>
</body>
</html>
