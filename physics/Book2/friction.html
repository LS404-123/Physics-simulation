<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ç‰©ç†æ¨¡æ“¬ï¼šæ‘©æ“¦åŠ›èˆ‡ç‰›é “ç¬¬äºŒå®šå¾‹</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- MathJax Configuration -->
    <script>
        window.MathJax = {
            tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
            svg: { fontCache: 'global' }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">

    <style>
        body { font-family: 'Inter', 'Noto Sans TC', sans-serif; }
        
        /* Custom Range Slider Styling */
        input[type=range] {
            -webkit-appearance: none; 
            background: transparent; 
        }
        input[type=range]:focus { outline: none; }
        
        /* Webkit Slider Thumb */
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 24px;
            width: 24px;
            border-radius: 50%;
            background: #ffffff;
            border: 2px solid #4f46e5;
            cursor: pointer;
            margin-top: -10px; 
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            transition: transform 0.1s;
        }
        input[type=range]::-webkit-slider-thumb:hover { transform: scale(1.1); }
        
        /* Webkit Track */
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 6px;
            cursor: pointer;
            background: #e2e8f0;
            border-radius: 999px;
        }

        /* Red Theme for Force Slider */
        .slider-force::-webkit-slider-thumb { border-color: #ef4444; }
        .slider-green::-webkit-slider-thumb { border-color: #16a34a; }

        /* Glassmorphism utilities */
        .glass {
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
        }
        
        /* Hide scrollbar for clean UI but keep functionality */
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
    </style>
</head>
<body class="bg-slate-100 text-slate-800 h-screen flex flex-col overflow-hidden">

    <!-- Header -->
    <nav class="bg-white/80 backdrop-blur-md border-b border-slate-200 px-4 py-3 lg:px-6 flex-shrink-0 flex justify-between items-center z-30">
        <div class="flex items-center gap-3">
            <div class="bg-indigo-600 text-white p-2 rounded-lg shadow-sm">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
                </svg>
            </div>
            <div>
                <h1 class="text-base lg:text-lg font-bold tracking-tight text-slate-900 leading-tight">æ‘©æ“¦åŠ›èˆ‡é‹å‹•æ¨¡æ“¬</h1>
            </div>
        </div>
        <button onclick="toggleModal(true)" class="group flex items-center gap-2 bg-indigo-50 hover:bg-indigo-100 text-indigo-700 px-4 py-2 rounded-full text-sm font-bold transition border border-indigo-200">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
            </svg>
            <span class="hidden sm:inline">åŸç†è©³è§£</span>
            <span class="sm:hidden">åŸç†</span>
        </button>
    </nav>

    <!-- Main Layout -->
    <div class="flex flex-1 flex-col lg:flex-row h-full overflow-hidden relative">
        
        <!-- Left: Visualization (60% width on desktop) -->
        <div class="relative w-full lg:w-[60%] h-[45vh] lg:h-auto bg-slate-200/50 flex flex-col order-1">
            <!-- Canvas Layer -->
            <div class="absolute inset-0 z-0 bg-[radial-gradient(#e2e8f0_1px,transparent_1px)] [background-size:20px_20px]">
                <canvas id="simCanvas" class="w-full h-full block"></canvas>
            </div>

            <!-- Floating Status (Top Center) -->
            <div class="absolute top-4 left-1/2 transform -translate-x-1/2 z-10">
                <span id="statusBadge" class="px-4 py-1.5 rounded-full text-xs lg:text-sm font-bold shadow-lg transition-colors duration-300 bg-green-500 text-white flex items-center gap-2">
                    <span class="w-2 h-2 bg-white rounded-full animate-pulse"></span>
                    <span id="statusText">éœæ­¢</span>
                </span>
            </div>

            <!-- Floating Data Card (Top Right) -->
            <div class="absolute top-4 right-4 z-10 glass border border-white/60 p-3 lg:p-4 rounded-2xl shadow-xl min-w-[160px] lg:min-w-[200px] scale-90 origin-top-right lg:scale-100">
                <div class="text-[10px] font-bold text-slate-400 uppercase tracking-wider mb-2 border-b border-slate-200 pb-1">å¯¦æ™‚æ•¸æ“š</div>
                <div class="space-y-1.5 text-sm">
                    <div class="flex justify-between items-center">
                        <span class="text-slate-600">æ·¨åŠ› $F_{æ·¨}$</span>
                        <span class="font-mono font-bold text-indigo-600 bg-indigo-50 px-1.5 rounded"><span id="val_fnet">0.0</span> N</span>
                    </div>
                    <div class="flex justify-between items-center">
                        <span class="text-slate-600">åŠ é€Ÿåº¦ $a$</span>
                        <span class="font-mono font-bold text-indigo-600 bg-indigo-50 px-1.5 rounded"><span id="val_a">0.00</span> $m/s^2$</span>
                    </div>
                    <div class="flex justify-between items-center">
                        <span class="text-slate-600">é€Ÿåº¦ $v$</span>
                        <span class="font-mono font-bold text-indigo-600 bg-indigo-50 px-1.5 rounded"><span id="val_v">0.00</span> $m/s$</span>
                    </div>
                </div>
            </div>

            <!-- Legend (Bottom Center) -->
            <div class="absolute bottom-4 left-1/2 transform -translate-x-1/2 z-10 bg-white/90 px-4 py-2 rounded-full shadow-lg border border-white/50 flex gap-4 text-[10px] lg:text-xs font-bold text-slate-600 backdrop-blur-sm whitespace-nowrap">
                <span class="flex items-center gap-1.5"><span class="w-2.5 h-2.5 rounded-full bg-red-500 shadow-sm"></span> å¤–åŠ› F</span>
                <span class="flex items-center gap-1.5"><span class="w-2.5 h-2.5 rounded-full bg-green-500 shadow-sm"></span> æ‘©æ“¦åŠ› f</span>
                <span class="flex items-center gap-1.5"><span class="w-2.5 h-2.5 rounded-full bg-slate-800 shadow-sm"></span> æ­£å‘åŠ› R</span>
                <span class="flex items-center gap-1.5"><span class="w-2.5 h-2.5 rounded-full bg-purple-600 shadow-sm"></span> é‡åŠ› mg</span>
            </div>
        </div>

        <!-- Right: Controls & Graphs (40% width on desktop) -->
        <div class="w-full lg:w-[40%] bg-white lg:border-l border-slate-200 flex flex-col z-20 shadow-[0_-10px_40px_-15px_rgba(0,0,0,0.1)] lg:shadow-none order-2 h-[55vh] lg:h-auto">
            
            <!-- Scrollable Container -->
            <div class="flex-1 overflow-y-auto no-scrollbar p-4 lg:p-6 space-y-6">
                
                <!-- Graph Card -->
                <div class="bg-white rounded-2xl border border-slate-100 shadow-sm p-1">
                    <div class="flex items-center justify-between px-3 py-2">
                        <h3 class="font-bold text-slate-700 text-sm flex items-center gap-2">
                            <span class="w-1 h-4 bg-indigo-500 rounded-full"></span>
                            åŠ é€Ÿåº¦ vs å¤–åŠ›
                        </h3>
                    </div>
                    <!-- Changed aspect ratio from [2.2/1] to [1.5/1] to make the graph box taller/larger -->
                    <div class="relative w-full aspect-[1.5/1] bg-slate-50 rounded-xl overflow-hidden border border-slate-100">
                        <canvas id="graphCanvas" class="w-full h-full"></canvas>
                    </div>
                    <p class="text-center text-[10px] text-slate-400 py-1">Xè»¸: å¤–åŠ›å¤§å° | Yè»¸: åŠ é€Ÿåº¦ (å›ºå®šæ¯”ä¾‹)</p>
                </div>

                <!-- Controls -->
                <div class="space-y-6 pb-8">
                    
                    <!-- Reset Button -->
                    <div class="flex justify-end">
                        <button id="btn_reset" class="flex items-center gap-2 bg-slate-100 hover:bg-slate-200 text-slate-600 font-bold py-2 px-4 rounded-lg transition-colors text-sm shadow-sm border border-slate-200">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                            </svg>
                            é‡ç½® (Reset)
                        </button>
                    </div>

                    <!-- Force Control -->
                    <div class="bg-slate-50 p-4 lg:p-5 rounded-2xl border border-slate-200 shadow-sm">
                        <div class="flex justify-between items-center mb-4">
                            <label class="font-bold text-slate-700 flex items-center gap-2">
                                <span class="bg-red-500 text-white w-6 h-6 rounded-lg flex items-center justify-center text-xs shadow-red-200 shadow-md">F</span>
                                æ–½åŠ å¤–åŠ›
                            </label>
                            <span class="font-mono font-bold text-xl text-red-600 w-24 text-right tabular-nums"><span id="disp_F">0.0</span> <span class="text-sm text-red-400">N</span></span>
                        </div>
                        
                        <!-- Center Zero Slider -->
                        <div class="relative h-12 flex items-center justify-center group">
                            <!-- Background Track Gradient -->
                            <div class="absolute w-full h-2 bg-gradient-to-r from-red-100 via-slate-200 to-red-100 rounded-full"></div>
                            <!-- Center Marker -->
                            <div class="absolute left-1/2 w-0.5 h-4 bg-slate-400 -translate-x-1/2 rounded-full"></div>
                            <!-- Tick Marks -->
                            <div class="absolute left-[25%] w-px h-2 bg-slate-300"></div>
                            <div class="absolute left-[75%] w-px h-2 bg-slate-300"></div>

                            <input type="range" id="input_F" min="-50" max="50" step="0.5" value="0" class="absolute w-full z-10 opacity-0 cursor-pointer h-full">
                            
                            <!-- Custom Interactive Thumb (Visual Only, moved by JS) -->
                            <div id="thumb_F_visual" class="absolute left-1/2 w-6 h-6 bg-white border-2 border-red-500 rounded-full shadow-md transform -translate-x-1/2 pointer-events-none transition-transform duration-75 flex items-center justify-center">
                                <div class="w-1.5 h-1.5 bg-red-500 rounded-full"></div>
                            </div>
                        </div>
                        
                        <div class="flex justify-between text-[10px] font-bold text-slate-400 mt-[-5px] uppercase tracking-wider px-1">
                            <span>âŸµ å‘å·¦æ¨</span>
                            <span>å‘å³æ¨ âŸ¶</span>
                        </div>
                    </div>

                    <!-- Properties Group -->
                    <div class="grid grid-cols-1 gap-4">
                        <!-- Mass -->
                        <div>
                            <div class="flex justify-between mb-2">
                                <label class="text-sm font-semibold text-slate-600">ç‰©é«”è³ªé‡ ($m$)</label>
                                <span class="text-sm font-mono font-bold text-indigo-600 bg-indigo-50 px-2 py-0.5 rounded"><span id="disp_m">5.0</span> kg</span>
                            </div>
                            <!-- Updated Min Mass to 2.0 to prevent acceleration > 25m/s^2 -->
                            <input type="range" id="input_m" min="2.0" max="20" step="0.5" value="5.0" class="w-full">
                        </div>

                        <!-- Max Static Friction -->
                        <div>
                            <div class="flex justify-between mb-2">
                                <label class="text-sm font-semibold text-slate-600">æœ€å¤§æ‘©æ“¦åŠ› ($f_{max}$)</label>
                                <span class="text-sm font-mono font-bold text-green-600 bg-green-50 px-2 py-0.5 rounded"><span id="disp_fLimit">20.0</span> N</span>
                            </div>
                            <input type="range" id="input_fLimit" min="0" max="50" step="0.5" value="20.0" class="w-full slider-green">
                        </div>
                    </div>
                    
                    <div class="pt-4 border-t border-slate-100 text-center">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Info Modal -->
    <div id="infoModal" class="hidden fixed inset-0 bg-slate-900/60 backdrop-blur-sm z-50 flex items-center justify-center p-4 transition-opacity duration-300 opacity-0">
        <div class="bg-white rounded-3xl shadow-2xl max-w-2xl w-full max-h-[90vh] overflow-y-auto flex flex-col transform scale-95 transition-transform duration-300" id="modalContent">
            <div class="bg-indigo-600 p-6 text-white flex justify-between items-start">
                <div>
                    <h2 class="text-2xl font-bold mb-1">åŒå­¸ä½ å¥½ï¼ğŸ‘‹</h2>
                    <p class="text-indigo-100 text-sm opacity-90">è«‹èŠ±ä¸€é»æ™‚é–“é–±è®€ä»¥ä¸‹åŸç†ï¼Œé€™å°è€ƒè©¦å¾ˆæœ‰å¹«åŠ©ã€‚</p>
                </div>
                <button onclick="toggleModal(false)" class="bg-white/20 hover:bg-white/30 rounded-full p-1 transition">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            
            <div class="p-6 lg:p-8 text-slate-600 space-y-8">
                <!-- Concept 1 -->
                <div class="flex gap-5">
                    <div class="flex-shrink-0 w-12 h-12 bg-blue-100 text-blue-600 rounded-2xl flex items-center justify-center font-bold text-xl shadow-sm">1</div>
                    <div>
                        <h3 class="font-bold text-lg text-slate-900 mb-2">å¤–åŠ›çš„æ–¹å‘</h3>
                        <p class="leading-relaxed text-sm">
                            åœ¨é€™å€‹æ¨¡æ“¬ä¸­ï¼Œ<span class="text-red-500 font-bold">æ­£å€¼ (+F)</span> ä»£è¡¨å‘å³çš„åŠ›ï¼Œ<span class="text-red-500 font-bold">è² å€¼ (-F)</span> ä»£è¡¨å‘å·¦çš„åŠ›ã€‚
                        </p>
                    </div>
                </div>

                <!-- Concept 2 -->
                <div class="flex gap-5">
                    <div class="flex-shrink-0 w-12 h-12 bg-green-100 text-green-600 rounded-2xl flex items-center justify-center font-bold text-xl shadow-sm">2</div>
                    <div>
                        <h3 class="font-bold text-lg text-slate-900 mb-2">æ‘©æ“¦åŠ›çš„æ–¹å‘</h3>
                        <p class="leading-relaxed text-sm">
                            æ‘©æ“¦åŠ›æ°¸é èˆ‡é‹å‹•è¶¨å‹¢æˆ–é‹å‹•æ–¹å‘<span class="font-bold">ç›¸å</span>ã€‚
                        </p>
                    </div>
                </div>

                <!-- Concept 3 -->
                <div class="flex gap-5">
                    <div class="flex-shrink-0 w-12 h-12 bg-purple-100 text-purple-600 rounded-2xl flex items-center justify-center font-bold text-xl shadow-sm">3</div>
                    <div>
                        <h3 class="font-bold text-lg text-slate-900 mb-2">åœ–è¡¨åˆ†æ</h3>
                        <p class="leading-relaxed text-sm">
                            æˆ‘å€‘ä½¿ç”¨ $F$ å° $a$ çš„åœ–è¡¨ï¼ˆå–æ•¸å€¼å¤§å°ï¼‰ã€‚é€™èƒ½æ¸…æ¥šé¡¯ç¤ºï¼šåªè¦å¤–åŠ›å¤§å°è¶…éæœ€å¤§æ‘©æ“¦åŠ›ï¼Œç‰©é«”å°±æœƒç”¢ç”ŸåŠ é€Ÿåº¦ã€‚
                        </p>
                    </div>
                </div>
            </div>

            <div class="p-4 border-t border-slate-100 bg-slate-50 flex justify-end">
                <button onclick="toggleModal(false)" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2.5 px-6 rounded-xl shadow-lg shadow-indigo-200 transform transition active:scale-95">
                    æ˜ç™½äº†ï¼Œé–‹å§‹å¯¦é©—ï¼
                </button>
            </div>
        </div>
    </div>

<script>
/**
 * ç‰©ç†å¼•æ“èˆ‡äº’å‹•é‚è¼¯
 * Physics Engine & Interaction Logic
 */

// Constants
const g = 9.81; // m/s^2

// State variables
let state = {
    m: 5.0,    // Mass (kg)
    F: 0.0,    // Applied Force (N)
    fLimit: 20.0, // Friction Limit (N)
    
    // Calculated
    N_force: 0,
    fActual: 0, // Signed Friction
    a: 0,       // Signed Acceleration
    v: 0,       // Velocity (m/s)
    
    // UI/Animation
    isMoving: false,
    mu: 0,      
    groundOffset: 0,
    blockX: 0
};

// DOM Elements
const canvasSim = document.getElementById('simCanvas');
const ctxSim = canvasSim.getContext('2d');
const canvasGraph = document.getElementById('graphCanvas');
const ctxGraph = canvasGraph.getContext('2d');

const ui = {
    inputF: document.getElementById('input_F'),
    inputM: document.getElementById('input_m'),
    inputFLimit: document.getElementById('input_fLimit'),
    btnReset: document.getElementById('btn_reset'),
    dispF: document.getElementById('disp_F'),
    dispM: document.getElementById('disp_m'),
    dispFLimit: document.getElementById('disp_fLimit'),
    valA: document.getElementById('val_a'),
    valV: document.getElementById('val_v'),
    valFnet: document.getElementById('val_fnet'),
    statusBadge: document.getElementById('statusBadge'),
    statusText: document.getElementById('statusText'),
    thumbVisual: document.getElementById('thumb_F_visual')
};

// Initialization
function init() {
    setupHighDPICanvas();
    window.addEventListener('resize', () => {
        setupHighDPICanvas();
        // Redraw immediately on resize
    });
    
    // Inputs
    ui.inputF.addEventListener('input', (e) => { 
        state.F = parseFloat(e.target.value); 
        // We don't call updatePhysics here anymore for 'v'
        // Just update visual thumb
        updateForceThumbPosition();
    });

    ui.inputM.addEventListener('input', (e) => { 
        state.m = parseFloat(e.target.value); 
    });

    ui.inputFLimit.addEventListener('input', (e) => {
        state.fLimit = parseFloat(e.target.value);
    });

    ui.btnReset.addEventListener('click', resetSimulation);

    // Initial update
    updateForceThumbPosition();
    
    // Start Animation Loop
    requestAnimationFrame(animate);
    
    // Show instruction modal on startup
    setTimeout(() => toggleModal(true), 500);
}

function resetSimulation() {
    state.v = 0;
    state.a = 0;
    state.F = 0;
    ui.inputF.value = 0;
    updateForceThumbPosition();
}

function setupHighDPICanvas() {
    const scale = window.devicePixelRatio || 1;
    [canvasSim, canvasGraph].forEach(canvas => {
        const rect = canvas.parentElement.getBoundingClientRect();
        canvas.width = rect.width * scale;
        canvas.height = rect.height * scale;
        canvas.style.width = rect.width + 'px';
        canvas.style.height = rect.height + 'px';
        const ctx = canvas.getContext('2d');
        ctx.scale(scale, scale);
    });
}

function updateForceThumbPosition() {
    // Map -50..50 to 0..100%
    const percent = ((state.F + 50) / 100) * 100;
    ui.thumbVisual.style.left = `${percent}%`;
    ui.thumbVisual.style.borderColor = Math.abs(state.F) > state.fLimit ? '#ef4444' : '#94a3b8';
}

function updateStatusBadge() {
    if (Math.abs(state.v) > 0.01) {
        ui.statusBadge.className = "px-4 py-1.5 rounded-full text-xs lg:text-sm font-bold shadow-lg transition-colors duration-300 bg-red-500 text-white flex items-center gap-2";
        ui.statusText.textContent = "åŠ é€Ÿ/æ»‘å‹•";
    } else {
        ui.statusBadge.className = "px-4 py-1.5 rounded-full text-xs lg:text-sm font-bold shadow-lg transition-colors duration-300 bg-green-500 text-white flex items-center gap-2";
        ui.statusText.textContent = "éœæ­¢";
    }
}

// Main Physics & Animation Loop
function animate() {
    const dt = 0.016; // approx 60fps fixed step
    
    // 1. Calculate Normal Force
    state.N_force = state.m * g;

    // 2. Determine Friction & Acceleration
    // Kinetic Friction logic: If moving, friction opposes velocity.
    // Static Friction logic: If v~0, friction opposes F up to limit.
    
    const isMoving = Math.abs(state.v) > 0.001;
    
    if (isMoving) {
        // Kinetic Region
        // Friction direction opposes velocity
        const frictionDir = -Math.sign(state.v);
        state.fActual = frictionDir * state.fLimit;
        
        // Net Force
        const fNet = state.F + state.fActual;
        state.a = fNet / state.m;
        
        // Update Velocity
        const newV = state.v + state.a * dt;
        
        // Zero-crossing check (Stop if friction causes reversal)
        // If sign changes and applied force isn't strong enough to drive it
        if (Math.sign(newV) !== Math.sign(state.v)) {
             // Check if F alone is enough to overcome static friction in the new direction
             // If not, we stop.
             // For simplicity, if we cross zero, we assume we stop for this frame, 
             // and next frame static logic takes over.
             state.v = 0;
             state.a = 0; // Momentary stop
        } else {
            state.v = newV;
        }

    } else {
        // Static Region
        state.v = 0;
        
        // Static friction opposes Applied Force
        if (Math.abs(state.F) <= state.fLimit) {
            state.fActual = -state.F;
            state.a = 0;
        } else {
            // Break away
            // Direction of acceleration matches Force
            const frictionDir = -Math.sign(state.F);
            state.fActual = frictionDir * state.fLimit;
            const fNet = state.F + state.fActual;
            state.a = fNet / state.m;
            
            // Start moving
            state.v += state.a * dt;
        }
    }
    
    // 3. Update Visual Position (Ground Scroll)
    if (Math.abs(state.v) > 0.001) {
        // Ground moves opposite to velocity
        state.groundOffset -= state.v * dt * 50; // *50 for visual scaling
        
        // Loop texture
        const patternW = 40;
        if (state.groundOffset > patternW) state.groundOffset -= patternW;
        if (state.groundOffset < -patternW) state.groundOffset += patternW;
        
        // Reset block jitter
        state.blockX = state.blockX * 0.9;
    } else {
        // Subtle spring back to center when static
        state.blockX = state.blockX * 0.9 + (state.F * 0.05) * 0.1;
    }

    // 4. Update UI Texts
    ui.dispF.textContent = state.F.toFixed(1);
    ui.dispM.textContent = state.m.toFixed(1);
    ui.dispFLimit.textContent = state.fLimit.toFixed(1);
    
    ui.valA.textContent = Math.abs(state.a).toFixed(2);
    ui.valV.textContent = Math.abs(state.v).toFixed(2);
    
    const netForceVal = Math.abs(state.F + state.fActual);
    ui.valFnet.textContent = netForceVal.toFixed(1);
    
    updateStatusBadge();

    // 5. Draw
    drawSimulation();
    drawGraph();

    requestAnimationFrame(animate);
}

// Drawing Helpers
function drawArrow(ctx, fromX, fromY, toX, toY, color, text, labelPos = 'top') {
    const headLen = 12;
    const angle = Math.atan2(toY - fromY, toX - fromX);
    
    // Stop line at base of arrowhead to prevent round cap protrusion
    const headAxialLen = headLen * Math.cos(Math.PI / 6);
    const endLineX = toX - headAxialLen * Math.cos(angle);
    const endLineY = toY - headAxialLen * Math.sin(angle);

    ctx.beginPath();
    ctx.lineCap = "round";
    ctx.strokeStyle = color;
    ctx.fillStyle = color;
    ctx.lineWidth = 4;
    
    ctx.moveTo(fromX, fromY);
    ctx.lineTo(endLineX, endLineY); // Stops before tip to allow head to fit cleanly
    ctx.stroke();
    
    // Arrowhead
    ctx.beginPath();
    ctx.moveTo(toX, toY);
    ctx.lineTo(toX - headLen * Math.cos(angle - Math.PI / 6), toY - headLen * Math.sin(angle - Math.PI / 6));
    ctx.lineTo(toX - headLen * Math.cos(angle + Math.PI / 6), toY - headLen * Math.sin(angle + Math.PI / 6));
    ctx.closePath();
    ctx.fill();

    if (text) {
        ctx.font = "bold 14px 'Inter', sans-serif";
        ctx.fillStyle = color;
        const midX = (fromX + toX) / 2;
        const midY = (fromY + toY) / 2;
        
        let tx = midX;
        let ty = midY;
        let align = 'center';
        
        if (labelPos === 'left') {
            tx -= 15;
            align = 'right';
        } else if (labelPos === 'right') {
            tx += 15;
            align = 'left';
        } else if (labelPos === 'bottom' || labelPos === true) {
            ty += 20;
        } else {
            // top or false
            ty -= 20;
        }

        // Draw background for legibility
        const metrics = ctx.measureText(text);
        ctx.save();
        ctx.fillStyle = "rgba(255,255,255,0.8)";
        let bx = tx;
        if (align === 'center') bx -= metrics.width/2;
        if (align === 'right') bx -= metrics.width;
        ctx.fillRect(bx - 2, ty - 10, metrics.width + 4, 20);
        ctx.restore();

        ctx.textAlign = align;
        ctx.textBaseline = "middle";
        ctx.fillText(text, tx, ty);
    }
}

function drawRoundedRect(ctx, x, y, width, height, radius) {
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + width - radius, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
    ctx.lineTo(x + width, y + height - radius);
    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    ctx.lineTo(x + radius, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();
}

function drawSimulation() {
    const width = canvasSim.parentElement.offsetWidth;
    const height = canvasSim.parentElement.offsetHeight;
    
    ctxSim.clearRect(0, 0, width, height);
    
    const floorY = height * 0.7;
    const blockW = 140;
    const blockH = 90;
    const centerX = width / 2;
    // Add dynamic jitter based on force state
    const blockVisualX = centerX + state.blockX; 
    const blockY = floorY - blockH;

    // 1. Draw Floor with moving texture
    ctxSim.save();
    ctxSim.beginPath();
    ctxSim.rect(0, floorY, width, height - floorY);
    ctxSim.fillStyle = "#f1f5f9";
    ctxSim.fill();
    ctxSim.strokeStyle = "#cbd5e1";
    ctxSim.lineWidth = 2;
    ctxSim.beginPath();
    ctxSim.moveTo(0, floorY);
    ctxSim.lineTo(width, floorY);
    ctxSim.stroke();

    // Texture
    ctxSim.strokeStyle = "#94a3b8";
    ctxSim.lineWidth = 2;
    const patternW = 40;
    const startX = (state.groundOffset % patternW) - patternW;
    for(let i = startX; i < width; i+=patternW) {
        ctxSim.beginPath();
        ctxSim.moveTo(i, floorY);
        ctxSim.lineTo(i - 15, floorY + 15);
        ctxSim.stroke();
    }
    ctxSim.restore();

    // 2. Draw Block (Stylized)
    ctxSim.save();
    
    // Setup Shadow for the block
    ctxSim.shadowColor = "rgba(0, 0, 0, 0.25)";
    ctxSim.shadowBlur = 20;
    ctxSim.shadowOffsetY = 10;
    ctxSim.shadowOffsetX = 0;

    // Main Body Gradient
    const gradient = ctxSim.createLinearGradient(blockVisualX - blockW/2, blockY, blockVisualX - blockW/2, blockY + blockH);
    gradient.addColorStop(0, "#4f46e5"); // Indigo 600
    gradient.addColorStop(1, "#4338ca"); // Indigo 700
    ctxSim.fillStyle = gradient;
    
    // Draw Fill (with shadow)
    ctxSim.beginPath();
    drawRoundedRect(ctxSim, blockVisualX - blockW/2, blockY, blockW, blockH, 12);
    ctxSim.fill();
    
    // Reset Shadow for subsequent strokes to avoid double shadowing
    ctxSim.shadowColor = "transparent";
    ctxSim.shadowBlur = 0;
    ctxSim.shadowOffsetY = 0;

    // Border
    ctxSim.strokeStyle = "#312e81"; // Dark Indigo border
    ctxSim.lineWidth = 3;
    ctxSim.stroke();
    
    // Inner Highlight (optional, but looks nice)
    ctxSim.strokeStyle = "rgba(255,255,255,0.2)";
    ctxSim.lineWidth = 1;
    drawRoundedRect(ctxSim, blockVisualX - blockW/2 + 3, blockY + 3, blockW - 6, blockH - 6, 10);
    ctxSim.stroke();

    // Text
    ctxSim.fillStyle = "#ffffff"; 
    ctxSim.font = "bold 20px 'Inter'";
    ctxSim.textAlign = "center";
    ctxSim.textBaseline = "middle";
    ctxSim.fillText(state.m + " kg", blockVisualX, blockY + blockH/2);
    ctxSim.restore();

    // 3. Draw Forces
    const centerBodyX = blockVisualX;
    const centerBodyY = blockY + blockH/2;
    const scale = 3.5; 

    // A. Normal Force R & Gravity mg
    let lenN = Math.min(state.N_force * scale * 0.5, 120); // Scale down vertical slightly visual
    // R - From Top of Box, Label to Left
    drawArrow(ctxSim, centerBodyX, blockY, centerBodyX, blockY - lenN, "#1e293b", "R", 'left');
    
    // Weight Force (mg) - From Center of Mass, Label to Right
    drawArrow(ctxSim, centerBodyX, centerBodyY, centerBodyX, centerBodyY + lenN, "#9333ea", "mg", 'right');

    // C. Applied Force F (Signed)
    // Positive Force is Right, Negative Force is Left
    if (Math.abs(state.F) > 0.1) {
        // If F > 0 (Right), Arrow points Right, Starts from Right Edge
        // If F < 0 (Left), Arrow points Left, Starts from Left Edge
        const startX = (state.F > 0) ? (blockVisualX + blockW/2) : (blockVisualX - blockW/2);
        const direction = (state.F > 0) ? 1 : -1; 
        const lenF = Math.abs(state.F) * scale;
        const drawLenF = Math.min(lenF, width/2 - 60); 
        
        drawArrow(ctxSim, startX, centerBodyY, startX + (drawLenF * direction), centerBodyY, "#ef4444", `F=${Math.abs(state.F).toFixed(1)}`, false);
    }

    // D. Friction f (Signed)
    // If Moving: Opposes velocity
    // If Static: Opposes Force
    if (Math.abs(state.fActual) > 0.1) {
        const contactY = floorY;
        const startX = blockVisualX;
        // Direction from fActual (fActual is signed, + is Right)
        const direction = (state.fActual > 0) ? 1 : -1;
        const lenf = Math.abs(state.fActual) * scale;
        const drawLenf = Math.min(lenf, width/2 - 60);
        
        drawArrow(ctxSim, startX, contactY + 3, startX + (drawLenf * direction), contactY + 3, "#22c55e", `f=${Math.abs(state.fActual).toFixed(1)}`, true);
    }
}

function drawGraph() {
    const width = canvasGraph.parentElement.offsetWidth;
    const height = canvasGraph.parentElement.offsetHeight;
    
    // Reset transform for drawing
    ctxGraph.setTransform(1, 0, 0, 1, 0, 0);
    const scale = window.devicePixelRatio || 1;
    ctxGraph.scale(scale, scale);
    
    ctxGraph.clearRect(0, 0, width, height);

    const padding = { top: 20, right: 30, bottom: 30, left: 40 };
    const graphW = width - padding.left - padding.right;
    const graphH = height - padding.top - padding.bottom;

    // Ranges
    const maxF = 55;
    const maxA = 25; // Fixed scale to visualize slope change

    const getX = (val) => padding.left + (val / maxF) * graphW;
    const getY = (val) => padding.top + graphH - (val / maxA) * graphH;

    // Grid
    ctxGraph.beginPath();
    ctxGraph.strokeStyle = "#f1f5f9";
    ctxGraph.lineWidth = 1;
    for (let i = 0; i <= 5; i++) {
        const y = padding.top + (graphH / 5) * i;
        ctxGraph.moveTo(padding.left, y);
        ctxGraph.lineTo(width - padding.right, y);
    }
    for (let i = 0; i <= 5; i++) {
        const x = padding.left + (graphW / 5) * i;
        ctxGraph.moveTo(x, padding.top);
        ctxGraph.lineTo(x, height - padding.bottom);
    }
    ctxGraph.stroke();

    // Axes
    ctxGraph.beginPath();
    ctxGraph.strokeStyle = "#94a3b8";
    ctxGraph.lineWidth = 2;
    ctxGraph.fillStyle = "#94a3b8";

    // Y Axis Line
    ctxGraph.moveTo(padding.left, height - padding.bottom);
    ctxGraph.lineTo(padding.left, padding.top);
    ctxGraph.stroke();
    
    // Y Axis Arrow
    ctxGraph.beginPath();
    ctxGraph.moveTo(padding.left, padding.top - 5); // Tip
    ctxGraph.lineTo(padding.left - 4, padding.top + 5);
    ctxGraph.lineTo(padding.left + 4, padding.top + 5);
    ctxGraph.fill();

    // X Axis Line
    ctxGraph.beginPath();
    ctxGraph.moveTo(padding.left, height - padding.bottom);
    ctxGraph.lineTo(width - padding.right, height - padding.bottom);
    ctxGraph.stroke();

    // X Axis Arrow
    ctxGraph.beginPath();
    ctxGraph.moveTo(width - padding.right + 5, height - padding.bottom); // Tip
    ctxGraph.lineTo(width - padding.right - 5, height - padding.bottom - 4);
    ctxGraph.lineTo(width - padding.right - 5, height - padding.bottom + 4);
    ctxGraph.fill();

    // Theoretical Curve (Blue - Static Scenario)
    ctxGraph.beginPath();
    ctxGraph.strokeStyle = "#6366f1"; // Indigo 500
    ctxGraph.lineWidth = 3;
    ctxGraph.lineJoin = "round";

    // P1: Start
    ctxGraph.moveTo(getX(0), getY(0));
    // P2: Limit
    ctxGraph.lineTo(getX(state.fLimit), getY(0));
    // P3: End
    const finalA = (maxF - state.fLimit) / state.m;
    ctxGraph.lineTo(getX(maxF), getY(finalA));
    ctxGraph.stroke();

    // Highlight "Static Zone"
    ctxGraph.save();
    ctxGraph.fillStyle = "rgba(34, 197, 94, 0.1)"; // Green tint
    ctxGraph.fillRect(getX(0), padding.top, getX(state.fLimit) - getX(0), graphH);
    ctxGraph.restore();

    // f_max label
    const fLimX = getX(state.fLimit);
    ctxGraph.fillStyle = "#16a34a";
    ctxGraph.font = "bold 11px 'Inter'";
    ctxGraph.textAlign = "center";
    ctxGraph.fillText("f_max", fLimX, height - padding.bottom + 25);
    // Tick mark
    ctxGraph.beginPath();
    ctxGraph.strokeStyle = "#16a34a";
    ctxGraph.lineWidth = 1.5;
    ctxGraph.moveTo(fLimX, height - padding.bottom);
    ctxGraph.lineTo(fLimX, height - padding.bottom + 5);
    ctxGraph.stroke();

    // Current State Dot (Real-time dynamic)
    const curX = getX(Math.abs(state.F));
    const curY = getY(Math.abs(state.a));

    // Guide lines
    ctxGraph.beginPath();
    ctxGraph.strokeStyle = "#cbd5e1";
    ctxGraph.setLineDash([4, 4]);
    ctxGraph.moveTo(curX, height - padding.bottom);
    ctxGraph.lineTo(curX, curY);
    ctxGraph.lineTo(padding.left, curY);
    ctxGraph.stroke();
    ctxGraph.setLineDash([]);

    // Dot
    ctxGraph.beginPath();
    // Color logic: If decelerating (F=0, a!=0), show purple? Or standard Red/Green
    // Use Red if accelerating, Green if static, Orange if decelerating
    if (Math.abs(state.v) > 0.001 && Math.abs(state.F) < 0.1) {
        ctxGraph.fillStyle = "#f59e0b"; // Orange (Decelerating)
    } else {
        ctxGraph.fillStyle = (Math.abs(state.v) > 0.001) ? "#ef4444" : "#22c55e";
    }
    
    ctxGraph.arc(curX, curY, 6, 0, Math.PI * 2);
    ctxGraph.fill();
    ctxGraph.strokeStyle = "white";
    ctxGraph.lineWidth = 2;
    ctxGraph.stroke();
    
    // Labels
    ctxGraph.fillStyle = "#64748b";
    ctxGraph.font = "10px 'Inter'";
    ctxGraph.textAlign = "center";
    ctxGraph.fillText("0", padding.left, height - padding.bottom + 15);
    ctxGraph.fillText(maxF, width - padding.right, height - padding.bottom + 15);
    
    // Axis Titles
    ctxGraph.font = "bold 11px 'Noto Sans TC'";
    ctxGraph.fillText("å¤–åŠ› F /N", width / 2 + 10, height - 5);
    
    ctxGraph.save();
    ctxGraph.translate(12, height / 2);
    ctxGraph.rotate(-Math.PI / 2);
    ctxGraph.fillText("åŠ é€Ÿåº¦ a (ms^-2)", 0, 0);
    ctxGraph.restore();
}

// Modal Logic
function toggleModal(show) {
    const modal = document.getElementById('infoModal');
    const content = document.getElementById('modalContent');
    
    if (show) {
        modal.classList.remove('hidden');
        // Small timeout to allow display:block to apply before opacity transition
        setTimeout(() => {
            modal.classList.remove('opacity-0');
            content.classList.remove('scale-95');
            content.classList.add('scale-100');
        }, 10);
    } else {
        modal.classList.add('opacity-0');
        content.classList.remove('scale-100');
        content.classList.add('scale-95');
        setTimeout(() => {
            modal.classList.add('hidden');
        }, 300);
    }
}

window.onload = init;

</script>
</body>
</html>
