<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ç‰©ç†æ¨¡æ“¬ï¼šæ‘©æ“¦åŠ›èˆ‡ç‰›é “ç¬¬äºŒå®šå¾‹</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- MathJax Configuration -->
    <script>
        window.MathJax = {
            tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
            svg: { fontCache: 'global' }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">

    <style>
        body { font-family: 'Inter', 'Noto Sans TC', sans-serif; }
        
        /* Custom Range Slider Styling */
        input[type=range] {
            -webkit-appearance: none; 
            background: transparent; 
        }
        input[type=range]:focus { outline: none; }
        
        /* Webkit Slider Thumb */
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 24px;
            width: 24px;
            border-radius: 50%;
            background: #ffffff;
            border: 2px solid #4f46e5;
            cursor: pointer;
            margin-top: -10px; 
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            transition: transform 0.1s;
        }
        input[type=range]::-webkit-slider-thumb:hover { transform: scale(1.1); }
        
        /* Webkit Track */
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 6px;
            cursor: pointer;
            background: #e2e8f0;
            border-radius: 999px;
        }

        /* Red Theme for Force Slider */
        .slider-force::-webkit-slider-thumb { border-color: #ef4444; }
        .slider-green::-webkit-slider-thumb { border-color: #16a34a; }

        /* Glassmorphism utilities */
        .glass {
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
        }
        
        /* Hide scrollbar for clean UI but keep functionality */
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
    </style>
</head>
<body class="bg-slate-100 text-slate-800 h-screen flex flex-col overflow-hidden">

    <!-- Header -->
    <nav class="bg-white/80 backdrop-blur-md border-b border-slate-200 px-4 py-3 lg:px-6 flex-shrink-0 flex justify-between items-center z-30">
        <div class="flex items-center gap-3">
            <div class="bg-indigo-600 text-white p-2 rounded-lg shadow-sm">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
                </svg>
            </div>
            <div>
                <h1 class="text-base lg:text-lg font-bold tracking-tight text-slate-900 leading-tight">æ‘©æ“¦åŠ›èˆ‡é‹å‹•æ¨¡æ“¬</h1>
                <p class="text-[10px] lg:text-xs text-slate-500 font-medium hidden sm:block">Friction & Newton's 2nd Law</p>
            </div>
        </div>
        <button onclick="toggleModal(true)" class="group flex items-center gap-2 bg-indigo-50 hover:bg-indigo-100 text-indigo-700 px-4 py-2 rounded-full text-sm font-bold transition border border-indigo-200">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
            </svg>
            <span class="hidden sm:inline">åŸç†è©³è§£</span>
            <span class="sm:hidden">åŸç†</span>
        </button>
    </nav>

    <!-- Main Layout -->
    <div class="flex flex-1 flex-col lg:flex-row h-full overflow-hidden relative">
        
        <!-- Left: Visualization (60% width on desktop) -->
        <div class="relative w-full lg:w-[60%] h-[45vh] lg:h-auto bg-slate-200/50 flex flex-col order-1">
            <!-- Canvas Layer -->
            <div class="absolute inset-0 z-0 bg-[radial-gradient(#e2e8f0_1px,transparent_1px)] [background-size:20px_20px]">
                <canvas id="simCanvas" class="w-full h-full block"></canvas>
            </div>

            <!-- Floating Status (Top Center) -->
            <div class="absolute top-4 left-1/2 transform -translate-x-1/2 z-10">
                <span id="statusBadge" class="px-4 py-1.5 rounded-full text-xs lg:text-sm font-bold shadow-lg transition-colors duration-300 bg-green-500 text-white flex items-center gap-2">
                    <span class="w-2 h-2 bg-white rounded-full animate-pulse"></span>
                    <span id="statusText">éœæ­¢ (Static)</span>
                </span>
            </div>

            <!-- Floating Data Card (Top Right) -->
            <div class="absolute top-4 right-4 z-10 glass border border-white/60 p-3 lg:p-4 rounded-2xl shadow-xl min-w-[160px] lg:min-w-[200px] scale-90 origin-top-right lg:scale-100">
                <div class="text-[10px] font-bold text-slate-400 uppercase tracking-wider mb-2 border-b border-slate-200 pb-1">å¯¦æ™‚æ•¸æ“š</div>
                <div class="space-y-1.5 text-sm">
                    <div class="flex justify-between items-center">
                        <span class="text-slate-600">åˆåŠ› $F_{net}$</span>
                        <span class="font-mono font-bold text-indigo-600 bg-indigo-50 px-1.5 rounded"><span id="val_fnet">0.0</span> N</span>
                    </div>
                    <div class="flex justify-between items-center">
                        <span class="text-slate-600">åŠ é€Ÿåº¦ $a$</span>
                        <span class="font-mono font-bold text-indigo-600 bg-indigo-50 px-1.5 rounded"><span id="val_a">0.00</span> $m/s^2$</span>
                    </div>
                </div>
            </div>

            <!-- Legend (Bottom Center) -->
            <div class="absolute bottom-4 left-1/2 transform -translate-x-1/2 z-10 bg-white/90 px-4 py-2 rounded-full shadow-lg border border-white/50 flex gap-4 text-[10px] lg:text-xs font-bold text-slate-600 backdrop-blur-sm whitespace-nowrap">
                <span class="flex items-center gap-1.5"><span class="w-2.5 h-2.5 rounded-full bg-red-500 shadow-sm"></span> å¤–åŠ› F</span>
                <span class="flex items-center gap-1.5"><span class="w-2.5 h-2.5 rounded-full bg-green-500 shadow-sm"></span> æ‘©æ“¦åŠ› f</span>
                <span class="flex items-center gap-1.5"><span class="w-2.5 h-2.5 rounded-full bg-slate-800 shadow-sm"></span> æ­£å‘åŠ› R</span>
                <span class="flex items-center gap-1.5"><span class="w-2.5 h-2.5 rounded-full bg-purple-600 shadow-sm"></span> é‡åŠ› mg</span>
            </div>
        </div>

        <!-- Right: Controls & Graphs (40% width on desktop) -->
        <div class="w-full lg:w-[40%] bg-white lg:border-l border-slate-200 flex flex-col z-20 shadow-[0_-10px_40px_-15px_rgba(0,0,0,0.1)] lg:shadow-none order-2 h-[55vh] lg:h-auto">
            
            <!-- Scrollable Container -->
            <div class="flex-1 overflow-y-auto no-scrollbar p-4 lg:p-6 space-y-6">
                
                <!-- Graph Card -->
                <div class="bg-white rounded-2xl border border-slate-100 shadow-sm p-1">
                    <div class="flex items-center justify-between px-3 py-2">
                        <h3 class="font-bold text-slate-700 text-sm flex items-center gap-2">
                            <span class="w-1 h-4 bg-indigo-500 rounded-full"></span>
                            åŠ é€Ÿåº¦ vs å¤–åŠ›
                        </h3>
                    </div>
                    <!-- Changed aspect ratio from [2.2/1] to [1.5/1] to make the graph box taller/larger -->
                    <div class="relative w-full aspect-[1.5/1] bg-slate-50 rounded-xl overflow-hidden border border-slate-100">
                        <canvas id="graphCanvas" class="w-full h-full"></canvas>
                    </div>
                    <p class="text-center text-[10px] text-slate-400 py-1">Xè»¸: å¤–åŠ›å¤§å° | Yè»¸: åŠ é€Ÿåº¦ (è‡ªå‹•ç¸®æ”¾)</p>
                </div>

                <!-- Controls -->
                <div class="space-y-6 pb-8">
                    
                    <!-- Force Control -->
                    <div class="bg-slate-50 p-4 lg:p-5 rounded-2xl border border-slate-200 shadow-sm">
                        <div class="flex justify-between items-center mb-4">
                            <label class="font-bold text-slate-700 flex items-center gap-2">
                                <span class="bg-red-500 text-white w-6 h-6 rounded-lg flex items-center justify-center text-xs shadow-red-200 shadow-md">F</span>
                                æ–½åŠ å¤–åŠ›
                            </label>
                            <span class="font-mono font-bold text-xl text-red-600 w-24 text-right tabular-nums"><span id="disp_F">0.0</span> <span class="text-sm text-red-400">N</span></span>
                        </div>
                        
                        <!-- Center Zero Slider -->
                        <div class="relative h-12 flex items-center justify-center group">
                            <!-- Background Track Gradient -->
                            <div class="absolute w-full h-2 bg-gradient-to-r from-red-100 via-slate-200 to-red-100 rounded-full"></div>
                            <!-- Center Marker -->
                            <div class="absolute left-1/2 w-0.5 h-4 bg-slate-400 -translate-x-1/2 rounded-full"></div>
                            <!-- Tick Marks -->
                            <div class="absolute left-[25%] w-px h-2 bg-slate-300"></div>
                            <div class="absolute left-[75%] w-px h-2 bg-slate-300"></div>

                            <input type="range" id="input_F" min="-50" max="50" step="0.5" value="0" class="absolute w-full z-10 opacity-0 cursor-pointer h-full">
                            
                            <!-- Custom Interactive Thumb (Visual Only, moved by JS) -->
                            <div id="thumb_F_visual" class="absolute left-1/2 w-6 h-6 bg-white border-2 border-red-500 rounded-full shadow-md transform -translate-x-1/2 pointer-events-none transition-transform duration-75 flex items-center justify-center">
                                <div class="w-1.5 h-1.5 bg-red-500 rounded-full"></div>
                            </div>
                        </div>
                        
                        <div class="flex justify-between text-[10px] font-bold text-slate-400 mt-[-5px] uppercase tracking-wider px-1">
                            <span>âŸµ å‘å·¦æ¨ (Left)</span>
                            <span>å‘å³æ¨ (Right) âŸ¶</span>
                        </div>
                    </div>

                    <!-- Properties Group -->
                    <div class="grid grid-cols-1 gap-4">
                        <!-- Mass -->
                        <div>
                            <div class="flex justify-between mb-2">
                                <label class="text-sm font-semibold text-slate-600">ç‰©é«”è³ªé‡ ($m$)</label>
                                <span class="text-sm font-mono font-bold text-indigo-600 bg-indigo-50 px-2 py-0.5 rounded"><span id="disp_m">5.0</span> kg</span>
                            </div>
                            <input type="range" id="input_m" min="0.5" max="20" step="0.5" value="5.0" class="w-full">
                        </div>

                        <!-- Max Static Friction -->
                        <div>
                            <div class="flex justify-between mb-2">
                                <label class="text-sm font-semibold text-slate-600">æœ€å¤§éœæ‘©æ“¦åŠ› ($f_{s,max}$)</label>
                                <span class="text-sm font-mono font-bold text-green-600 bg-green-50 px-2 py-0.5 rounded"><span id="disp_fLimit">20.0</span> N</span>
                            </div>
                            <input type="range" id="input_fLimit" min="0" max="50" step="0.5" value="20.0" class="w-full slider-green">
                        </div>
                    </div>
                    
                    <div class="pt-4 border-t border-slate-100 text-center">
                        <p class="text-[10px] text-slate-400">Physics Engine v2.0 &bull; Designed for HK DSE</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Info Modal -->
    <div id="infoModal" class="hidden fixed inset-0 bg-slate-900/60 backdrop-blur-sm z-50 flex items-center justify-center p-4 transition-opacity duration-300 opacity-0">
        <div class="bg-white rounded-3xl shadow-2xl max-w-2xl w-full max-h-[90vh] overflow-y-auto flex flex-col transform scale-95 transition-transform duration-300" id="modalContent">
            <div class="bg-indigo-600 p-6 text-white flex justify-between items-start">
                <div>
                    <h2 class="text-2xl font-bold mb-1">ğŸ‘¨â€ğŸ« è€å¸«çš„ç‰©ç†å°æ•™å®¤</h2>
                    <p class="text-indigo-100 text-sm opacity-90">HKDSE Physics - Force and Motion</p>
                </div>
                <button onclick="toggleModal(false)" class="bg-white/20 hover:bg-white/30 rounded-full p-1 transition">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            
            <div class="p-6 lg:p-8 text-slate-600 space-y-8">
                <!-- Section 1 -->
                <div class="flex gap-5">
                    <div class="flex-shrink-0 w-12 h-12 bg-indigo-100 text-indigo-600 rounded-2xl flex items-center justify-center font-bold text-xl shadow-sm">1</div>
                    <div>
                        <h3 class="font-bold text-lg text-slate-900 mb-2">ç ´é™¤è¿·æ€ï¼šæ‘©æ“¦åŠ›ä¸ä¸€å®šæ˜¯ $\mu R$ï¼Ÿ</h3>
                        <p class="leading-relaxed text-sm">
                            é€™æ˜¯è€ƒè©¦å¸¸çŠ¯çš„éŒ¯èª¤ï¼æ‘©æ“¦åŠ›çš„å¤§å°å–æ±ºæ–¼ç‰©é«”çš„ç‹€æ…‹ï¼š
                        </p>
                        <ul class="mt-2 space-y-2 text-sm bg-slate-50 p-4 rounded-lg border border-slate-100">
                            <li>ğŸ›‘ <strong>éœæ­¢éšæ®µ (Static)ï¼š</strong> ç•¶å¤–åŠ›å°æ–¼æœ€å¤§éœæ‘©æ“¦åŠ›æ™‚ï¼Œæ‘©æ“¦åŠ›æ˜¯ã€Œè¢«å‹•ã€çš„ã€‚<strong>$f = F_{applied}$</strong> (æ•¸å€¼ç›¸ç­‰ï¼Œæ–¹å‘ç›¸å)ï¼Œæ­¤æ™‚ $f \neq \mu R$ã€‚</li>
                            <li>ğŸƒ <strong>é‹å‹•éšæ®µ (Kinetic)ï¼š</strong> åªæœ‰ç•¶ $F > f_{max}$ æ™‚ï¼Œç‰©é«”é–‹å§‹æ»‘å‹•ï¼Œæ‘©æ“¦åŠ›æ‰é”åˆ°æ†å®šå€¼ (åœ¨æ­¤ç°¡åŒ–æ¨¡å‹ä¸­)ã€‚</li>
                        </ul>
                    </div>
                </div>

                <!-- Section 2 -->
                <div class="flex gap-5">
                    <div class="flex-shrink-0 w-12 h-12 bg-red-100 text-red-600 rounded-2xl flex items-center justify-center font-bold text-xl shadow-sm">2</div>
                    <div>
                        <h3 class="font-bold text-lg text-slate-900 mb-2">å¾åœ–è¡¨çœ‹ç‰›é “ç¬¬äºŒå®šå¾‹ ($F=ma$)</h3>
                        <p class="leading-relaxed text-sm">
                            è©¦è‘—æ”¹è®Šå¤–åŠ› $F$ï¼Œè§€å¯Ÿå³æ–¹ $a-F$ åœ–è¡¨çš„è®ŠåŒ–ï¼š
                        </p>
                         <ul class="mt-2 space-y-1 text-sm list-disc list-inside text-slate-500">
                            <li><strong>æˆªè· (Intercept)ï¼š</strong> åœ–è¡¨åœ¨ $X$ è»¸ä¸Šçš„æˆªè·æ­£æ˜¯æœ€å¤§æ‘©æ“¦åŠ› $f_{max}$ã€‚</li>
                            <li><strong>æ–œç‡ (Slope)ï¼š</strong> ç•¶åœ–ç·šé–‹å§‹ä¸Šå‡ï¼Œè©¦æ€è€ƒæ–œç‡ä»£è¡¨ä»€éº¼ï¼Ÿ(æç¤ºï¼šç”± $F - f = ma$ å¯çŸ¥ $a = \frac{1}{m}F - \frac{f}{m}$ï¼Œæ–œç‡èˆ‡è³ªé‡ $m$ æœ‰é—œ)ã€‚</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="p-4 border-t border-slate-100 bg-slate-50 flex justify-end">
                <button onclick="toggleModal(false)" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2.5 px-6 rounded-xl shadow-lg shadow-indigo-200 transform transition active:scale-95">
                    å„ä½åŒå­¸ï¼Œé–‹å§‹å¯¦é©—å§ï¼ğŸš€
                </button>
            </div>
        </div>
    </div>

<script>
/**
 * ç‰©ç†å¼•æ“èˆ‡äº’å‹•é‚è¼¯
 * Physics Engine & Interaction Logic
 */

// Constants
const g = 9.81; // m/s^2

// State variables
let state = {
    m: 5.0,    // Mass (kg)
    F: 0.0,    // Applied Force (N), can be negative (Right) or positive (Left)
    fLimit: 20.0, // Friction Limit (N) [0, 50]
    
    // Calculated
    N_force: 0,
    fActual: 0, // Signed Friction
    a: 0,       // Signed Acceleration
    isMoving: false,
    mu: 0,      // Static friction coeff
    
    // Animation
    groundOffset: 0,
    velocity: 0, // Visual velocity
    blockX: 0    // For subtle spring effect on start
};

// DOM Elements
const canvasSim = document.getElementById('simCanvas');
const ctxSim = canvasSim.getContext('2d');
const canvasGraph = document.getElementById('graphCanvas');
const ctxGraph = canvasGraph.getContext('2d');

const ui = {
    inputF: document.getElementById('input_F'),
    inputM: document.getElementById('input_m'),
    inputFLimit: document.getElementById('input_fLimit'),
    dispF: document.getElementById('disp_F'),
    dispM: document.getElementById('disp_m'),
    dispFLimit: document.getElementById('disp_fLimit'),
    valA: document.getElementById('val_a'),
    valFnet: document.getElementById('val_fnet'),
    statusBadge: document.getElementById('statusBadge'),
    statusText: document.getElementById('statusText'),
    thumbVisual: document.getElementById('thumb_F_visual')
};

// Initialization
function init() {
    setupHighDPICanvas();
    window.addEventListener('resize', () => {
        setupHighDPICanvas();
        drawGraph(); // Redraw static graph immediately
    });
    
    // Event Listeners
    ui.inputF.addEventListener('input', (e) => { 
        state.F = parseFloat(e.target.value); 
        updatePhysics(); 
    });

    ui.inputM.addEventListener('input', (e) => { 
        state.m = parseFloat(e.target.value); 
        updatePhysics(); 
    });

    ui.inputFLimit.addEventListener('input', (e) => {
        state.fLimit = parseFloat(e.target.value);
        updatePhysics();
    });

    updatePhysics();
    animate();
    
    // Initial Graph draw
    setTimeout(drawGraph, 100);

    // Show instruction modal on startup
    setTimeout(() => toggleModal(true), 500);
}

function setupHighDPICanvas() {
    const scale = window.devicePixelRatio || 1;
    
    [canvasSim, canvasGraph].forEach(canvas => {
        const rect = canvas.parentElement.getBoundingClientRect();
        canvas.width = rect.width * scale;
        canvas.height = rect.height * scale;
        canvas.style.width = rect.width + 'px';
        canvas.style.height = rect.height + 'px';
        const ctx = canvas.getContext('2d');
        ctx.scale(scale, scale);
    });
}

function updatePhysics() {
    state.N_force = state.m * g;
    state.mu = state.fLimit / (state.m * g);

    const absF = Math.abs(state.F);
    
    if (absF <= state.fLimit) {
        // Static Region
        state.isMoving = false;
        state.a = 0;
        state.fActual = -state.F; 
    } else {
        // Kinetic Region
        state.isMoving = true;
        const sign = Math.sign(state.F); 
        state.fActual = -sign * state.fLimit;
        const netForce = state.F + state.fActual;
        state.a = netForce / state.m;
    }

    // Update UI Texts
    ui.dispF.textContent = state.F.toFixed(1);
    ui.dispM.textContent = state.m.toFixed(1);
    ui.dispFLimit.textContent = state.fLimit.toFixed(1);
    ui.valA.textContent = Math.abs(state.a).toFixed(2);
    
    const netForceVal = Math.abs(state.F + state.fActual);
    ui.valFnet.textContent = netForceVal.toFixed(1);

    // Update Visuals
    updateForceThumbPosition();
    updateStatusBadge();
    drawGraph();
}

function updateForceThumbPosition() {
    // Map -50..50 to 0..100%
    const percent = ((state.F + 50) / 100) * 100;
    ui.thumbVisual.style.left = `${percent}%`;
    ui.thumbVisual.style.borderColor = Math.abs(state.F) > state.fLimit ? '#ef4444' : '#94a3b8';
}

function updateStatusBadge() {
    if (state.isMoving) {
        ui.statusBadge.className = "px-4 py-1.5 rounded-full text-xs lg:text-sm font-bold shadow-lg transition-colors duration-300 bg-red-500 text-white flex items-center gap-2";
        ui.statusText.textContent = "åŠ é€Ÿæ»‘å‹• (Moving)";
    } else {
        ui.statusBadge.className = "px-4 py-1.5 rounded-full text-xs lg:text-sm font-bold shadow-lg transition-colors duration-300 bg-green-500 text-white flex items-center gap-2";
        ui.statusText.textContent = "éœæ­¢ (Static)";
    }
}

// Animation Loop
function animate() {
    const dt = 0.016; 
    
    if (state.isMoving) {
        state.velocity += state.a * dt * 8; // Speed multiplier for visual effect
        state.groundOffset += state.velocity * dt;
        
        // Loop texture
        const patternW = 40;
        if (state.groundOffset > patternW) state.groundOffset -= patternW;
        if (state.groundOffset < -patternW) state.groundOffset += patternW;
        
        // Reset block jitter
        state.blockX = state.blockX * 0.9;
    } else {
        state.velocity = 0;
        // Subtle spring back to center when force is released or static
        state.blockX = state.blockX * 0.9 + (state.F * 0.05) * 0.1;
    }

    drawSimulation();
    requestAnimationFrame(animate);
}

// Drawing Helpers
function drawArrow(ctx, fromX, fromY, toX, toY, color, text, labelBelow = false) {
    const headLen = 12;
    const angle = Math.atan2(toY - fromY, toX - fromX);
    
    // Stop line at base of arrowhead to prevent round cap protrusion
    const headAxialLen = headLen * Math.cos(Math.PI / 6);
    const endLineX = toX - headAxialLen * Math.cos(angle);
    const endLineY = toY - headAxialLen * Math.sin(angle);

    ctx.beginPath();
    ctx.lineCap = "round";
    ctx.strokeStyle = color;
    ctx.fillStyle = color;
    ctx.lineWidth = 4;
    
    ctx.moveTo(fromX, fromY);
    ctx.lineTo(endLineX, endLineY); // Stops before tip to allow head to fit cleanly
    ctx.stroke();
    
    // Arrowhead
    ctx.beginPath();
    ctx.moveTo(toX, toY);
    ctx.lineTo(toX - headLen * Math.cos(angle - Math.PI / 6), toY - headLen * Math.sin(angle - Math.PI / 6));
    ctx.lineTo(toX - headLen * Math.cos(angle + Math.PI / 6), toY - headLen * Math.sin(angle + Math.PI / 6));
    ctx.closePath();
    ctx.fill();

    if (text) {
        ctx.font = "bold 14px 'Inter', sans-serif";
        ctx.fillStyle = color;
        const midX = (fromX + toX) / 2;
        const midY = (fromY + toY) / 2;
        const textOffset = labelBelow ? 25 : -15;
        
        // Background for text to make it readable over lines
        const metrics = ctx.measureText(text);
        ctx.save();
        ctx.fillStyle = "rgba(255,255,255,0.8)";
        ctx.fillRect(midX - metrics.width/2 - 4, midY + textOffset - 12, metrics.width + 8, 16);
        ctx.restore();

        ctx.textAlign = "center";
        ctx.fillText(text, midX, midY + textOffset);
    }
}

function drawRoundedRect(ctx, x, y, width, height, radius) {
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + width - radius, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
    ctx.lineTo(x + width, y + height - radius);
    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    ctx.lineTo(x + radius, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();
}

function drawSimulation() {
    const width = canvasSim.parentElement.offsetWidth;
    const height = canvasSim.parentElement.offsetHeight;
    
    ctxSim.clearRect(0, 0, width, height);
    
    const floorY = height * 0.7;
    const blockW = 140;
    const blockH = 90;
    const centerX = width / 2;
    // Add dynamic jitter based on force state
    const blockVisualX = centerX + state.blockX; 
    const blockY = floorY - blockH;

    // 1. Draw Floor with moving texture
    ctxSim.save();
    ctxSim.beginPath();
    ctxSim.rect(0, floorY, width, height - floorY);
    ctxSim.fillStyle = "#f1f5f9";
    ctxSim.fill();
    ctxSim.strokeStyle = "#cbd5e1";
    ctxSim.lineWidth = 2;
    ctxSim.beginPath();
    ctxSim.moveTo(0, floorY);
    ctxSim.lineTo(width, floorY);
    ctxSim.stroke();

    // Texture
    ctxSim.strokeStyle = "#94a3b8";
    ctxSim.lineWidth = 2;
    const patternW = 40;
    const startX = (state.groundOffset % patternW) - patternW;
    for(let i = startX; i < width; i+=patternW) {
        ctxSim.beginPath();
        ctxSim.moveTo(i, floorY);
        ctxSim.lineTo(i - 15, floorY + 15);
        ctxSim.stroke();
    }
    ctxSim.restore();

    // 2. Draw Block (Stylized)
    ctxSim.save();
    
    // Setup Shadow for the block
    ctxSim.shadowColor = "rgba(0, 0, 0, 0.25)";
    ctxSim.shadowBlur = 20;
    ctxSim.shadowOffsetY = 10;
    ctxSim.shadowOffsetX = 0;

    // Main Body Gradient
    const gradient = ctxSim.createLinearGradient(blockVisualX - blockW/2, blockY, blockVisualX - blockW/2, blockY + blockH);
    gradient.addColorStop(0, "#4f46e5"); // Indigo 600
    gradient.addColorStop(1, "#4338ca"); // Indigo 700
    ctxSim.fillStyle = gradient;
    
    // Draw Fill (with shadow)
    ctxSim.beginPath();
    drawRoundedRect(ctxSim, blockVisualX - blockW/2, blockY, blockW, blockH, 12);
    ctxSim.fill();
    
    // Reset Shadow for subsequent strokes to avoid double shadowing
    ctxSim.shadowColor = "transparent";
    ctxSim.shadowBlur = 0;
    ctxSim.shadowOffsetY = 0;

    // Border
    ctxSim.strokeStyle = "#312e81"; // Dark Indigo border
    ctxSim.lineWidth = 3;
    ctxSim.stroke();
    
    // Inner Highlight (optional, but looks nice)
    ctxSim.strokeStyle = "rgba(255,255,255,0.2)";
    ctxSim.lineWidth = 1;
    drawRoundedRect(ctxSim, blockVisualX - blockW/2 + 3, blockY + 3, blockW - 6, blockH - 6, 10);
    ctxSim.stroke();

    // Text
    ctxSim.fillStyle = "#ffffff"; 
    ctxSim.font = "bold 20px 'Inter'";
    ctxSim.textAlign = "center";
    ctxSim.textBaseline = "middle";
    ctxSim.fillText(state.m + " kg", blockVisualX, blockY + blockH/2);
    ctxSim.restore();

    // 3. Draw Forces
    const centerBodyX = blockVisualX;
    const centerBodyY = blockY + blockH/2;
    const scale = 3.5; 

    // A. Normal Force R & Gravity mg
    let lenN = Math.min(state.N_force * scale * 0.5, 120); // Scale down vertical slightly visual
    drawArrow(ctxSim, centerBodyX, blockY, centerBodyX, blockY - lenN, "#1e293b", "R", false);
    
    // Weight Force (mg) - Originating from Center of Mass
    drawArrow(ctxSim, centerBodyX, centerBodyY, centerBodyX, centerBodyY + lenN, "#9333ea", "mg", true);

    // C. Applied Force F (Signed)
    if (Math.abs(state.F) > 0.1) {
        const startX = (state.F > 0) ? (blockVisualX - blockW/2) : (blockVisualX + blockW/2);
        const direction = (state.F > 0) ? -1 : 1; 
        const lenF = Math.abs(state.F) * scale;
        const drawLenF = Math.min(lenF, width/2 - 60); 
        
        drawArrow(ctxSim, startX, centerBodyY, startX + (drawLenF * direction), centerBodyY, "#ef4444", `F=${Math.abs(state.F).toFixed(1)}`, false);
    }

    // D. Friction f (Signed)
    if (Math.abs(state.fActual) > 0.1) {
        const contactY = floorY;
        const startX = blockVisualX;
        const direction = (state.fActual > 0) ? -1 : 1;
        const lenf = Math.abs(state.fActual) * scale;
        const drawLenf = Math.min(lenf, width/2 - 60);
        
        drawArrow(ctxSim, startX, contactY + 3, startX + (drawLenf * direction), contactY + 3, "#22c55e", `f=${Math.abs(state.fActual).toFixed(1)}`, true);
    }
}

function drawGraph() {
    const width = canvasGraph.parentElement.offsetWidth;
    const height = canvasGraph.parentElement.offsetHeight;
    
    // Reset transform for drawing
    ctxGraph.setTransform(1, 0, 0, 1, 0, 0);
    const scale = window.devicePixelRatio || 1;
    ctxGraph.scale(scale, scale);
    
    ctxGraph.clearRect(0, 0, width, height);

    const padding = { top: 20, right: 30, bottom: 30, left: 40 };
    const graphW = width - padding.left - padding.right;
    const graphH = height - padding.top - padding.bottom;

    // Ranges
    const maxF = 55;
    const maxA = 55 / state.m;

    const getX = (val) => padding.left + (val / maxF) * graphW;
    const getY = (val) => padding.top + graphH - (val / maxA) * graphH;

    // Grid
    ctxGraph.beginPath();
    ctxGraph.strokeStyle = "#f1f5f9";
    ctxGraph.lineWidth = 1;
    for (let i = 0; i <= 5; i++) {
        const y = padding.top + (graphH / 5) * i;
        ctxGraph.moveTo(padding.left, y);
        ctxGraph.lineTo(width - padding.right, y);
    }
    for (let i = 0; i <= 5; i++) {
        const x = padding.left + (graphW / 5) * i;
        ctxGraph.moveTo(x, padding.top);
        ctxGraph.lineTo(x, height - padding.bottom);
    }
    ctxGraph.stroke();

    // Axes
    ctxGraph.beginPath();
    ctxGraph.strokeStyle = "#94a3b8";
    ctxGraph.lineWidth = 2;
    ctxGraph.fillStyle = "#94a3b8";

    // Y Axis Line
    ctxGraph.moveTo(padding.left, height - padding.bottom);
    ctxGraph.lineTo(padding.left, padding.top);
    ctxGraph.stroke();
    
    // Y Axis Arrow
    ctxGraph.beginPath();
    ctxGraph.moveTo(padding.left, padding.top - 5); // Tip
    ctxGraph.lineTo(padding.left - 4, padding.top + 5);
    ctxGraph.lineTo(padding.left + 4, padding.top + 5);
    ctxGraph.fill();

    // X Axis Line
    ctxGraph.beginPath();
    ctxGraph.moveTo(padding.left, height - padding.bottom);
    ctxGraph.lineTo(width - padding.right, height - padding.bottom);
    ctxGraph.stroke();

    // X Axis Arrow
    ctxGraph.beginPath();
    ctxGraph.moveTo(width - padding.right + 5, height - padding.bottom); // Tip
    ctxGraph.lineTo(width - padding.right - 5, height - padding.bottom - 4);
    ctxGraph.lineTo(width - padding.right - 5, height - padding.bottom + 4);
    ctxGraph.fill();

    // Theoretical Curve (Static then Linear)
    ctxGraph.beginPath();
    ctxGraph.strokeStyle = "#6366f1"; // Indigo 500
    ctxGraph.lineWidth = 3;
    ctxGraph.lineJoin = "round";

    // P1: Start
    ctxGraph.moveTo(getX(0), getY(0));
    // P2: Limit
    ctxGraph.lineTo(getX(state.fLimit), getY(0));
    // P3: End
    const finalA = (maxF - state.fLimit) / state.m;
    ctxGraph.lineTo(getX(maxF), getY(finalA));
    ctxGraph.stroke();

    // Highlight "Static Zone"
    ctxGraph.save();
    ctxGraph.fillStyle = "rgba(34, 197, 94, 0.1)"; // Green tint
    ctxGraph.fillRect(getX(0), padding.top, getX(state.fLimit) - getX(0), graphH);
    ctxGraph.restore();

    // f_max label
    const fLimX = getX(state.fLimit);
    ctxGraph.fillStyle = "#16a34a";
    ctxGraph.font = "bold 11px 'Inter'";
    ctxGraph.textAlign = "center";
    ctxGraph.fillText("f_max", fLimX, height - padding.bottom + 25);
    // Tick mark
    ctxGraph.beginPath();
    ctxGraph.strokeStyle = "#16a34a";
    ctxGraph.lineWidth = 1.5;
    ctxGraph.moveTo(fLimX, height - padding.bottom);
    ctxGraph.lineTo(fLimX, height - padding.bottom + 5);
    ctxGraph.stroke();

    // Current State Dot
    const curX = getX(Math.abs(state.F));
    const curY = getY(Math.abs(state.a));

    // Guide lines
    ctxGraph.beginPath();
    ctxGraph.strokeStyle = "#cbd5e1";
    ctxGraph.setLineDash([4, 4]);
    ctxGraph.moveTo(curX, height - padding.bottom);
    ctxGraph.lineTo(curX, curY);
    ctxGraph.lineTo(padding.left, curY);
    ctxGraph.stroke();
    ctxGraph.setLineDash([]);

    // Dot
    ctxGraph.beginPath();
    ctxGraph.fillStyle = state.isMoving ? "#ef4444" : "#22c55e";
    ctxGraph.arc(curX, curY, 6, 0, Math.PI * 2);
    ctxGraph.fill();
    ctxGraph.strokeStyle = "white";
    ctxGraph.lineWidth = 2;
    ctxGraph.stroke();
    
    // Labels
    ctxGraph.fillStyle = "#64748b";
    ctxGraph.font = "10px 'Inter'";
    ctxGraph.textAlign = "center";
    ctxGraph.fillText("0", padding.left, height - padding.bottom + 15);
    ctxGraph.fillText(maxF, width - padding.right, height - padding.bottom + 15);
    
    // Axis Titles
    ctxGraph.font = "bold 11px 'Noto Sans TC'";
    ctxGraph.fillText("å¤–åŠ› F", width / 2 + 10, height - 5);
    
    ctxGraph.save();
    ctxGraph.translate(12, height / 2);
    ctxGraph.rotate(-Math.PI / 2);
    ctxGraph.fillText("åŠ é€Ÿåº¦ a", 0, 0);
    ctxGraph.restore();
}

// Modal Logic
function toggleModal(show) {
    const modal = document.getElementById('infoModal');
    const content = document.getElementById('modalContent');
    
    if (show) {
        modal.classList.remove('hidden');
        // Small timeout to allow display:block to apply before opacity transition
        setTimeout(() => {
            modal.classList.remove('opacity-0');
            content.classList.remove('scale-95');
            content.classList.add('scale-100');
        }, 10);
    } else {
        modal.classList.add('opacity-0');
        content.classList.remove('scale-100');
        content.classList.add('scale-95');
        setTimeout(() => {
            modal.classList.add('hidden');
        }, 300);
    }
}

window.onload = init;

</script>
</body>
</html>
