<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>物理力學模擬：力的合成與分解</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap');
        
        body {
            font-family: 'Noto Sans TC', sans-serif;
            background-color: #f3f4f6;
            color: #1f2937;
            overflow: hidden; /* 防止雙重滾動 */
        }

        .canvas-container {
            background-color: #ffffff;
            background-image: 
                linear-gradient(#e5e7eb 1px, transparent 1px),
                linear-gradient(90deg, #e5e7eb 1px, transparent 1px);
            background-size: 20px 20px;
            background-position: center center;
            cursor: crosshair;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.05);
            border-radius: 8px;
            position: relative;
        }

        /* 表格樣式 */
        .data-table th, .data-table td {
            padding: 8px;
            text-align: center;
            border-bottom: 1px solid #e5e7eb;
            font-size: 0.9rem;
        }
        .data-table th {
            background-color: #f9fafb;
            font-weight: 600;
            color: #4b5563;
        }
        .data-table tr:last-child td {
            border-bottom: none;
        }
        
        /* Modal 動畫 */
        #introModal {
            transition: opacity 0.3s ease-in-out;
        }
        .modal-content {
            transform: scale(0.95);
            transition: transform 0.3s ease-in-out;
        }
        #introModal.show .modal-content {
            transform: scale(1);
        }

        /* 按鈕 hover 效果 */
        .btn-action {
            transition: all 0.2s;
        }
        .btn-action:active {
            transform: scale(0.95);
        }

        /* 數值顯示不重疊 */
        .vector-label {
            background: rgba(255, 255, 255, 0.85);
            padding: 2px 4px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            pointer-events: none;
            white-space: nowrap;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body class="h-screen flex flex-col">

    <!-- 頂部導航 -->
    <header class="bg-slate-800 text-white p-3 shadow-md flex justify-between items-center z-20 shrink-0">
        <div class="flex items-center gap-3">
            <div class="bg-blue-600 p-2 rounded-lg">
                <i class="fas fa-vector-square text-xl"></i>
            </div>
            <div>
                <h1 class="text-lg font-bold tracking-wide">互動物理教室</h1>
                <p class="text-xs text-slate-300">力的合成與分解</p>
            </div>
        </div>
        <button onclick="showModal()" class="bg-blue-600 hover:bg-blue-500 text-white px-4 py-2 rounded-md text-sm font-medium transition flex items-center gap-2">
            <i class="fas fa-info-circle"></i> 教學原理
        </button>
    </header>

    <!-- 主要內容區 -->
    <main class="flex-1 flex flex-col lg:flex-row overflow-hidden">
        
        <!-- 左側：控制與數據面板 -->
        <aside class="w-full lg:w-96 bg-white border-r border-gray-200 flex flex-col shadow-lg z-10 overflow-y-auto">
            
            <!-- 控制區 -->
            <div class="p-5 border-b border-gray-100">
                <h2 class="text-sm font-bold text-gray-500 uppercase tracking-wider mb-3">情境設定</h2>
                <div class="grid grid-cols-2 gap-2 mb-4">
                    <button onclick="loadScenario(1)" class="btn-action bg-slate-100 hover:bg-slate-200 text-slate-700 py-2 px-3 rounded text-sm font-medium border border-slate-300">
                        <i class="fas fa-arrows-alt-h mr-1"></i> 前後拔河
                    </button>
                    <button onclick="loadScenario(2)" class="btn-action bg-slate-100 hover:bg-slate-200 text-slate-700 py-2 px-3 rounded text-sm font-medium border border-slate-300">
                        <i class="fas fa-share-alt mr-1"></i> Y字型平衡
                    </button>
                </div>
                
                <div class="flex justify-between items-center mb-2">
                    <h2 class="text-sm font-bold text-gray-500 uppercase tracking-wider">自由操作</h2>
                    <span id="forceCount" class="text-xs bg-blue-100 text-blue-800 px-2 py-0.5 rounded-full">0/4</span>
                </div>
                <div class="flex gap-2 mb-4">
                    <button onclick="addVector()" id="addBtn" class="btn-action flex-1 bg-green-600 hover:bg-green-700 text-white py-2 rounded text-sm font-bold shadow-sm">
                        <i class="fas fa-plus mr-1"></i> 增加力
                    </button>
                    <button onclick="clearVectors()" class="btn-action flex-1 bg-red-500 hover:bg-red-600 text-white py-2 rounded text-sm font-bold shadow-sm">
                        <i class="fas fa-trash-alt mr-1"></i> 清除所有
                    </button>
                </div>

                <h2 class="text-sm font-bold text-gray-500 uppercase tracking-wider mb-3">顯示設定</h2>
                <div class="space-y-2">
                    <label class="flex items-center space-x-2 cursor-pointer p-2 hover:bg-gray-50 rounded">
                        <input type="checkbox" id="showComponents" class="w-4 h-4 text-blue-600 rounded focus:ring-blue-500" onchange="draw()">
                        <span class="text-sm text-gray-700">顯示 X / Y 分量</span>
                    </label>
                    <label class="flex items-center space-x-2 cursor-pointer p-2 hover:bg-gray-50 rounded">
                        <input type="checkbox" id="showResultant" class="w-4 h-4 text-red-600 rounded focus:ring-red-500" checked onchange="draw()">
                        <span class="text-sm font-bold text-red-600">顯示合力</span>
                    </label>
                    <label class="flex items-center space-x-2 cursor-pointer p-2 hover:bg-gray-50 rounded">
                        <input type="checkbox" id="showValues" class="w-4 h-4 text-gray-600 rounded focus:ring-gray-500" checked onchange="draw()">
                        <span class="text-sm text-gray-700">顯示數值標籤</span>
                    </label>
                </div>
            </div>

            <!-- 數據表 -->
            <div class="flex-1 p-0 overflow-auto">
                <div class="sticky top-0 bg-gray-50 px-5 py-2 border-b border-gray-200">
                    <h2 class="text-sm font-bold text-gray-700">力學分析</h2>
                </div>
                <table class="w-full data-table">
                    <thead>
                        <tr>
                            <th>力</th>
                            <th>量值 (N)</th>
                            <th>X 分量 (N)</th>
                            <th>Y 分量 (N)</th>
                        </tr>
                    </thead>
                    <tbody id="vectorTableBody">
                        <!-- JS 動態生成 -->
                    </tbody>
                    <tfoot class="bg-red-50 font-bold text-red-700 border-t-2 border-red-200">
                        <tr id="resultantRow">
                            <td>合力 F<sub>合</sub></td>
                            <td id="resMag">0</td>
                            <td id="resX">0</td>
                            <td id="resY">0</td>
                        </tr>
                    </tfoot>
                </table>
                <div class="p-4 text-xs text-gray-500 italic">
                    <p class="mb-1">合力大小 F<sub>合</sub> = &radic;(F<sub>x</sub>² + F<sub>y</sub>²)</p>
                    <p>* 假設 1 格線長度 = 5 牛頓 (N)</p>
                </div>
            </div>
        </aside>

        <!-- 右側：Canvas 區域 -->
        <div class="flex-1 relative bg-gray-100 overflow-hidden flex items-center justify-center p-4">
            <div id="canvasWrapper" class="relative shadow-2xl rounded-lg overflow-hidden border-4 border-white">
                <canvas id="simulationCanvas"></canvas>
                <!-- 浮動提示 -->
                <div class="absolute top-4 right-4 bg-white/90 backdrop-blur px-3 py-2 rounded shadow text-xs text-gray-600 pointer-events-none">
                    <p><i class="fas fa-mouse-pointer"></i> 拖曳箭頭端點改變力</p>
                    <p><i class="fas fa-th"></i> 自動對齊格線</p>
                </div>
            </div>
        </div>
    </main>

    <!-- 教學彈窗 (Modal) -->
    <div id="introModal" class="fixed inset-0 bg-black/60 z-50 flex items-center justify-center backdrop-blur-sm opacity-0 pointer-events-none">
        <div class="modal-content bg-white rounded-xl shadow-2xl w-full max-w-2xl mx-4 overflow-hidden flex flex-col max-h-[90vh]">
            <div class="bg-slate-800 text-white p-5 flex justify-between items-center">
                <h2 class="text-xl font-bold flex items-center gap-2">
                    <i class="fas fa-chalkboard-teacher"></i> 老師的話
                </h2>
                <button onclick="closeModal()" class="text-gray-400 hover:text-white transition">
                    <i class="fas fa-times text-xl"></i>
                </button>
            </div>
            
            <div class="p-6 overflow-y-auto text-gray-700 space-y-4">
                <div class="bg-blue-50 border-l-4 border-blue-500 p-4 rounded">
                    <h3 class="font-bold text-blue-800 mb-1">各位同學好！</h3>
                    <p class="text-sm">歡迎來到這個物理實驗空間。今日我們會利用互動模擬，拆解平面上多於一個力的合成問題。</p>
                </div>

                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mt-4">
                    <div>
                        <h4 class="font-bold text-gray-800 mb-2 border-b pb-1">核心原理：向量合成</h4>
                        <ul class="list-disc list-inside text-sm space-y-1 ml-1">
                            <li>力是向量，具備<strong>大小</strong>和<strong>方向</strong>。</li>
                            <li>當多個力作用於同一點時，我們可以找到一個<strong>合力</strong>。</li>
                        </ul>
                    </div>
                    <div>
                        <h4 class="font-bold text-gray-800 mb-2 border-b pb-1">操作方法：正交分解法</h4>
                        <ol class="list-decimal list-inside text-sm space-y-1 ml-1">
                            <li>將所有斜向的力<strong>分解</strong>為水平 (X) 和垂直 (Y) 分量。</li>
                            <li>將所有 X 分量相加，所有 Y 分量相加。</li>
                            <li>利用畢氏定理找出最終合力的大小。</li>
                        </ol>
                    </div>
                </div>

                <div class="mt-4 p-4 bg-yellow-50 rounded border border-yellow-200 text-sm">
                    <p><strong><i class="fas fa-lightbulb text-yellow-500"></i> 小提示：</strong> 在模擬中，你可以開啟「顯示 X/Y 分量」來觀察每個力是如何被拆解的。注意觀察紅色粗線（合力）如何隨著藍色分力改變！</p>
                </div>
            </div>

            <div class="p-4 bg-gray-50 border-t flex justify-end">
                <button onclick="closeModal()" class="bg-blue-600 hover:bg-blue-700 text-white px-6 py-2 rounded-lg font-bold shadow transition transform hover:-translate-y-0.5">
                    開始模擬
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- 變數設定 ---
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvasWrapper');
        
        // 狀態管理
        let vectors = []; // 存儲向量物件 {x, y, color, id} (相對於中心點)
        const colors = ['#2563eb', '#16a34a', '#d97706', '#9333ea']; // 藍, 綠, 黃, 紫
        const maxVectors = 4;
        let isDragging = -1; // 當前正在拖曳的向量索引，-1 表示無
        
        // 顯示設定
        const gridSize = 20; // 格線大小 (px)
        const scaleFactor = 5; // 1 grid = 5N
        let origin = { x: 0, y: 0 }; // 畫布中心點
        
        // --- 初始化 ---
        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // 綁定滑鼠/觸控事件
            canvas.addEventListener('mousedown', handlePointerDown);
            canvas.addEventListener('mousemove', handlePointerMove);
            window.addEventListener('mouseup', handlePointerUp);
            
            // Touch support
            canvas.addEventListener('touchstart', (e) => handlePointerDown(e.touches[0]));
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                handlePointerMove(e.touches[0]);
            });
            window.addEventListener('touchend', handlePointerUp);

            // 初始情境
            loadScenario(1);
            
            // 顯示教學 Modal
            setTimeout(showModal, 500);
        }

        function resizeCanvas() {
            // 設置為容器大小
            const wrapper = document.getElementById('canvasWrapper');
            // 限制最大寬高，保持美觀
            const width = Math.min(wrapper.parentElement.clientWidth - 40, 800);
            const height = Math.min(wrapper.parentElement.clientHeight - 40, 600);
            
            canvas.width = width;
            canvas.height = height;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            
            origin = { x: width / 2, y: height / 2 };
            draw();
        }

        // --- 核心邏輯 ---

        // Helper for subscripts
        function toSubscript(num) {
            const map = { '0': '₀', '1': '₁', '2': '₂', '3': '₃', '4': '₄', '5': '₅', '6': '₆', '7': '₇', '8': '₈', '9': '₉' };
            return num.toString().split('').map(d => map[d] || d).join('');
        }

        // Helper for 3 sig figs
        function formatSigFig(val) {
            if (Math.abs(val) < 0.01) return "0";
            return Number(val).toPrecision(3);
        }

        function addVector(vx = 100, vy = -100) {
            if (vectors.length >= maxVectors) {
                alert("同學，最多只能加 4 個力喔！這樣觀察比較清楚。");
                return;
            }
            vectors.push({
                x: vx,
                y: vy,
                color: colors[vectors.length],
                id: Date.now()
            });
            updateUI();
            draw();
        }

        function removeVector(index) {
            vectors.splice(index, 1);
            // 重新分配顏色
            vectors.forEach((v, i) => v.color = colors[i]);
            updateUI();
            draw();
        }

        function clearVectors() {
            vectors = [];
            updateUI();
            draw();
        }

        function loadScenario(type) {
            clearVectors();
            if (type === 1) {
                // 前後拔河
                vectors.push({ x: 140, y: 0, color: colors[0], id: 1 });
                vectors.push({ x: -100, y: 0, color: colors[1], id: 2 });
            } else if (type === 2) {
                // Y字型
                vectors.push({ x: 0, y: -120, color: colors[0], id: 1 }); // 向上
                vectors.push({ x: 100, y: 60, color: colors[1], id: 2 });  // 右下
                vectors.push({ x: -100, y: 60, color: colors[2], id: 3 }); // 左下
            }
            updateUI();
            draw();
        }

        // --- 繪圖功能 ---

        function draw() {
            // 清空畫布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 1. 繪製座標軸
            drawAxes();
            
            // 2. 繪製物體 (中心點)
            ctx.beginPath();
            ctx.arc(origin.x, origin.y, 8, 0, Math.PI * 2);
            ctx.fillStyle = '#1e293b';
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();

            let totalX = 0;
            let totalY = 0;

            // 3. 繪製每個向量
            const showComponents = document.getElementById('showComponents').checked;
            const showValues = document.getElementById('showValues').checked;

            vectors.forEach((v, index) => {
                totalX += v.x;
                totalY += v.y;

                // 畫分量
                if (showComponents) {
                    drawComponents(v.x, v.y, v.color);
                }

                // 畫主向量
                const labelSub = toSubscript(index + 1);
                drawArrow(origin.x, origin.y, origin.x + v.x, origin.y + v.y, v.color, 3, `F${labelSub}`, showValues);
                
                // 拖曳熱區 (Debug用，實際不可見，但在處理鼠標事件時會用到)
                // ctx.beginPath(); ctx.arc(origin.x + v.x, origin.y + v.y, 10, 0, Math.PI*2); ctx.stroke();
            });

            // 4. 繪製合力
            if (document.getElementById('showResultant').checked && vectors.length > 0) {
                // 稍微半透明的紅色，為了不完全遮住下面的線
                const resColor = '#ef4444'; 
                
                // 畫合力分量投影 (虛線形成矩形/多邊形效果) - 這裡簡化為只畫結果
                // 如果想更進階，可以畫平行四邊形法則的輔助線，但多力時會太亂，故只畫結果
                
                drawArrow(origin.x, origin.y, origin.x + totalX, origin.y + totalY, resColor, 5, "合力", showValues, true);
            }

            // 更新表格數據
            updateTable(totalX, totalY);
        }

        function drawAxes() {
            ctx.strokeStyle = '#cbd5e1';
            ctx.lineWidth = 1;
            
            // X Axis
            ctx.beginPath();
            ctx.moveTo(0, origin.y);
            ctx.lineTo(canvas.width, origin.y);
            ctx.stroke();

            // Y Axis
            ctx.beginPath();
            ctx.moveTo(origin.x, 0);
            ctx.lineTo(origin.x, canvas.height);
            ctx.stroke();
        }

        function drawComponents(vx, vy, color) {
            ctx.setLineDash([5, 3]);
            ctx.lineWidth = 1.5;
            ctx.strokeStyle = color;
            ctx.globalAlpha = 0.6;
            ctx.fillStyle = color; // For arrow tips

            const headlen = 6; // Component arrow size

            // X Component (投影在X軸上)
            // 水平分量線
            ctx.beginPath();
            ctx.moveTo(origin.x, origin.y);
            ctx.lineTo(origin.x + vx, origin.y);
            ctx.stroke();

            // X Component Arrow Tip
            if (Math.abs(vx) > 5) {
                ctx.setLineDash([]); // Solid arrow
                ctx.beginPath();
                const angleX = Math.atan2(0, vx); // 0 or PI
                const tipX = origin.x + vx;
                const tipY = origin.y;
                ctx.moveTo(tipX, tipY);
                ctx.lineTo(tipX - headlen * Math.cos(angleX - Math.PI / 6), tipY - headlen * Math.sin(angleX - Math.PI / 6));
                ctx.lineTo(tipX - headlen * Math.cos(angleX + Math.PI / 6), tipY - headlen * Math.sin(angleX + Math.PI / 6));
                ctx.fill();
                ctx.setLineDash([5, 3]); // Restore dash
            }

            // Y Component (從水平分量末端畫上去)
            // 垂直分量線
            ctx.beginPath();
            ctx.moveTo(origin.x + vx, origin.y);
            ctx.lineTo(origin.x + vx, origin.y + vy);
            ctx.stroke();
            
            // Y Component Arrow Tip
            if (Math.abs(vy) > 5) {
                ctx.setLineDash([]);
                ctx.beginPath();
                const angleY = Math.atan2(vy, 0); // PI/2 or -PI/2
                const tipX2 = origin.x + vx;
                const tipY2 = origin.y + vy;
                ctx.moveTo(tipX2, tipY2);
                ctx.lineTo(tipX2 - headlen * Math.cos(angleY - Math.PI / 6), tipY2 - headlen * Math.sin(angleY - Math.PI / 6));
                ctx.lineTo(tipX2 - headlen * Math.cos(angleY + Math.PI / 6), tipY2 - headlen * Math.sin(angleY + Math.PI / 6));
                ctx.fill();
            }

            ctx.globalAlpha = 1.0;
            ctx.setLineDash([]);
        }

        function drawArrow(fromX, fromY, toX, toY, color, width, label, showLabel, isResultant = false) {
            const headlen = isResultant ? 15 : 10; // 箭頭大小
            const dx = toX - fromX;
            const dy = toY - fromY;
            const angle = Math.atan2(dy, dx);
            const length = Math.sqrt(dx * dx + dy * dy);

            if (length < 5) return; // 太短不畫

            const backX = toX - headlen * Math.cos(angle)*0.8;
            const backY = toY - headlen * Math.sin(angle)*0.8;

            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(backX, backY);
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.lineCap = 'round';
            if (isResultant) {
                // 合力加一點陰影讓它突出一點
                ctx.shadowColor = 'rgba(0,0,0,0.2)';
                ctx.shadowBlur = 5;
            }
            ctx.stroke();
            ctx.shadowBlur = 0;

            // 箭頭頭部
            ctx.beginPath();
            ctx.moveTo(toX, toY);
            ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
            ctx.fillStyle = color;
            ctx.fill();

            // 標籤
            if (showLabel) {
                // 計算文字位置 (線的中點旁邊)
                // const midX = (fromX + toX) / 2;
                // const midY = (fromY + toY) / 2;
                
                // 或者在箭頭末端，稍微推遠一點以容納新樣式 (增加距離以免遮住箭頭)
                const offsetDist = 28; 
                const labelX = toX + offsetDist * Math.cos(angle);
                const labelY = toY + offsetDist * Math.sin(angle);

                // 計算牛頓值
                const forceMag = Math.round(length / 20 * scaleFactor * 10) / 10; 

                drawLabel(label, labelX, labelY, color, isResultant);
            }
        }

        function drawLabel(text, x, y, color, isBold) {
            // 設定字體
            ctx.font = isBold ? "bold 14px 'Noto Sans TC'" : "bold 12px 'Noto Sans TC'";
            const metrics = ctx.measureText(text);
            const textWidth = metrics.width;
            const textHeight = isBold ? 16 : 14; 
            
            // 定義 Padding 與 Box 大小
            const paddingX = 10;
            const paddingY = 8;
            const boxWidth = textWidth + paddingX * 2;
            const boxHeight = textHeight + paddingY; // 上下總和

            // 計算 Box 起點 (讓 Box 中心點對齊 x, y)
            const startX = x - boxWidth / 2;
            const startY = y - boxHeight / 2;
            const radius = 8; // 圓角半徑

            ctx.save();
            
            // 1. 繪製陰影
            ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
            ctx.shadowBlur = 6;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;

            // 2. 繪製圓角矩形路徑
            ctx.beginPath();
            ctx.moveTo(startX + radius, startY);
            ctx.lineTo(startX + boxWidth - radius, startY);
            ctx.quadraticCurveTo(startX + boxWidth, startY, startX + boxWidth, startY + radius);
            ctx.lineTo(startX + boxWidth, startY + boxHeight - radius);
            ctx.quadraticCurveTo(startX + boxWidth, startY + boxHeight, startX + boxWidth - radius, startY + boxHeight);
            ctx.lineTo(startX + radius, startY + boxHeight);
            ctx.quadraticCurveTo(startX, startY + boxHeight, startX, startY + boxHeight - radius);
            ctx.lineTo(startX, startY + radius);
            ctx.quadraticCurveTo(startX, startY, startX + radius, startY);
            ctx.closePath();

            // 3. 填充背景 (稍微不透明的白色)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.fill();

            // 4. 繪製邊框 (與力的顏色相同)
            ctx.shadowColor = 'transparent'; // 邊框不要陰影
            ctx.lineWidth = 1.5;
            ctx.strokeStyle = color;
            ctx.stroke();

            // 5. 繪製文字
            ctx.fillStyle = color;
            ctx.textBaseline = 'middle';
            ctx.textAlign = 'center';
            ctx.fillText(text, x, y + 1); // +1 微調垂直居中

            ctx.restore();
            // 重置對齊設定以免影響其他繪圖
            ctx.textAlign = 'start';
        }

        // --- 互動事件 ---

        function handlePointerDown(e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // 檢查是否點擊到任何向量的箭頭端點 (允許一點誤差)
            // 倒序檢查，讓這上面的圖層優先被選中
            for (let i = vectors.length - 1; i >= 0; i--) {
                const v = vectors[i];
                const headX = origin.x + v.x;
                const headY = origin.y + v.y;
                const dist = Math.hypot(mouseX - headX, mouseY - headY);

                if (dist < 20) { // 20px 點擊範圍
                    isDragging = i;
                    canvas.style.cursor = 'grabbing';
                    return;
                }
            }
        }

        function handlePointerMove(e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            if (isDragging === -1) {
                // Hover effect logic
                let isHovering = false;
                for (let i = vectors.length - 1; i >= 0; i--) {
                    const v = vectors[i];
                    const headX = origin.x + v.x;
                    const headY = origin.y + v.y;
                    const dist = Math.hypot(mouseX - headX, mouseY - headY);

                    if (dist < 20) {
                        isHovering = true;
                        break;
                    }
                }
                canvas.style.cursor = isHovering ? 'grab' : 'crosshair';
                return;
            }

            // 計算相對於原點的新座標
            let newVx = mouseX - origin.x;
            let newVy = mouseY - origin.y;

            // Snap to grid (格線吸附)
            newVx = Math.round(newVx / gridSize) * gridSize;
            newVy = Math.round(newVy / gridSize) * gridSize;

            vectors[isDragging].x = newVx;
            vectors[isDragging].y = newVy;

            draw();
        }

        function handlePointerUp() {
            isDragging = -1;
            canvas.style.cursor = 'crosshair';
        }

        // --- 數據更新與 UI ---

        function updateUI() {
            const count = vectors.length;
            document.getElementById('forceCount').textContent = `${count}/${maxVectors}`;
            document.getElementById('addBtn').disabled = count >= maxVectors;
            if (count >= maxVectors) {
                document.getElementById('addBtn').classList.add('opacity-50', 'cursor-not-allowed');
            } else {
                document.getElementById('addBtn').classList.remove('opacity-50', 'cursor-not-allowed');
            }
        }

        function updateTable(totalX, totalY) {
            const tbody = document.getElementById('vectorTableBody');
            tbody.innerHTML = '';

            vectors.forEach((v, index) => {
                // 轉換座標系: Y軸向下為正 (Canvas)，物理通常向上為正。
                // 為了顯示習慣，我們顯示時將 Y 反轉
                const physY = -v.y; 
                const physX = v.x;

                const mag = Math.sqrt(physX**2 + physY**2);
                const forceN = (mag / 20) * scaleFactor; 
                
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td class="font-bold" style="color:${v.color}"> <button onclick="removeVector(${index})" class="ml-1 text-gray-400 hover:text-red-500"><i class="fas fa-times"></i></button> F<sub>${index+1}</sub> </td>
                    <td>${formatSigFig(forceN)}</td>
                    <td>${formatSigFig(physX / 20 * scaleFactor)}</td>
                    <td>${formatSigFig(physY / 20 * scaleFactor)}</td>
                `;
                tbody.appendChild(tr);
            });

            // 合力行
            const resMag = Math.sqrt(totalX**2 + totalY**2);
            const resN = (resMag / 20) * scaleFactor;
            const resPhysY = -totalY;

            document.getElementById('resMag').textContent = formatSigFig(resN);
            document.getElementById('resX').textContent = formatSigFig(totalX / 20 * scaleFactor);
            document.getElementById('resY').textContent = formatSigFig(resPhysY / 20 * scaleFactor);
        }

        // Modal Functions
        function showModal() {
            const modal = document.getElementById('introModal');
            modal.classList.remove('pointer-events-none');
            // Force reflow
            void modal.offsetWidth; 
            modal.classList.add('opacity-100', 'show');
        }

        function closeModal() {
            const modal = document.getElementById('introModal');
            modal.classList.remove('opacity-100', 'show');
            setTimeout(() => {
                modal.classList.add('pointer-events-none');
            }, 300);
        }

        // Start
        init();

    </script>
</body>
</html>