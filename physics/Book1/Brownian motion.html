<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>煙霧粒子布朗運動 (Brownian Motion)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f8fafc; color: #1e293b; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        .glass-panel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(0, 0, 0, 0.05);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }
    </style>
</head>
<body class="h-screen w-screen relative">

    <!-- HUD / Stats Panel -->
    <div class="absolute top-4 left-4 glass-panel p-5 rounded-xl z-10 w-72">
        <h2 class="text-xl font-bold mb-3 text-slate-800 flex items-center gap-2">
            <span class="w-2 h-6 bg-blue-600 rounded-full"></span>
            粒子數據
        </h2>
        
        <div class="mb-4">
            <div class="flex justify-between items-baseline">
                <div class="text-xs text-slate-500 font-bold uppercase tracking-wider">總移動距離 (Distance)</div>
                <div class="text-2xl font-mono text-blue-600 font-bold" id="distDisplay">0.00</div>
            </div>
            <div class="w-full bg-slate-100 h-1.5 mt-1 rounded-full overflow-hidden">
                <div class="bg-blue-200 h-full w-full animate-pulse"></div>
            </div>
            <div class="text-[10px] text-slate-400 mt-1 text-right">累積行走的所有路徑長度</div>
        </div>

        <div>
            <div class="flex justify-between items-baseline">
                <div class="text-xs text-slate-500 font-bold uppercase tracking-wider">位移 (Displacement)</div>
                <div class="text-2xl font-mono text-red-500 font-bold" id="dispDisplay">0.00</div>
            </div>
            <div class="w-full bg-slate-100 h-1.5 mt-1 rounded-full overflow-hidden">
                <div class="bg-red-200 h-full w-full animate-pulse"></div>
            </div>
            <div class="text-[10px] text-slate-400 mt-1 text-right">起點與終點的直線距離</div>
        </div>
    </div>

    <!-- Controls Panel -->
    <div class="absolute bottom-8 left-1/2 transform -translate-x-1/2 glass-panel px-8 py-4 rounded-full z-10 flex items-center gap-6 shadow-xl">
        <button id="btnToggle" class="bg-blue-600 hover:bg-blue-700 text-white px-6 py-2.5 rounded-full font-bold shadow-md transition-all active:scale-95 min-w-[100px] text-lg">
            開始
        </button>
        
        <button id="btnReset" class="bg-slate-200 hover:bg-slate-300 text-slate-700 px-6 py-2.5 rounded-full font-bold transition-all active:scale-95">
            重置
        </button>

        <div class="h-10 w-px bg-slate-300"></div>

        <div class="flex flex-col gap-1 items-center">
            <div class="flex justify-between w-full text-xs text-slate-500 font-bold uppercase">
                <span>慢</span>
                <span>模擬速度</span>
                <span>快</span>
            </div>
            <input type="range" id="speedSlider" min="1" max="10" value="2" class="w-40 h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600">
        </div>
    </div>

    <!-- Canvas -->
    <canvas id="simCanvas"></canvas>

    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        const distDisplay = document.getElementById('distDisplay');
        const dispDisplay = document.getElementById('dispDisplay');
        const btnToggle = document.getElementById('btnToggle');
        const btnReset = document.getElementById('btnReset');
        const speedSlider = document.getElementById('speedSlider');

        // State
        let width, height;
        let isRunning = false;
        let animationId;
        
        // Particle Physics State
        let startX, startY;
        let currentX, currentY;
        let vx, vy;                  // Velocity vector
        let collisionCountdown = 0;  // Frames until next direction change
        const PARTICLE_SPEED = 2;    // Constant speed (pixels per step)
        
        // Path History (Only stores collision points/vertices to optimize drawing)
        let pathVertices = []; 
        let totalDistance = 0;

        // Resize Canvas
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            if (pathVertices.length === 0) reset();
            else draw();
        }
        window.addEventListener('resize', resize);

        function reset() {
            startX = width / 2;
            startY = height / 2;
            currentX = startX;
            currentY = startY;
            
            // Initialize path with start point
            pathVertices = [{x: startX, y: startY}];
            totalDistance = 0;
            
            // Force immediate direction pick on start
            collisionCountdown = 0;
            
            updateStats();
            draw();
        }

        function updateStats() {
            const dx = currentX - startX;
            const dy = currentY - startY;
            const displacement = Math.sqrt(dx*dx + dy*dy);

            distDisplay.innerText = totalDistance.toFixed(2);
            dispDisplay.innerText = displacement.toFixed(2);
        }

        function step() {
            // 1. Move Particle
            currentX += vx;
            currentY += vy;
            
            // Update distance (since speed is constant, just add speed)
            totalDistance += PARTICLE_SPEED;

            // 2. Wall Bounce Logic
            // If it hits a wall, we reflect the velocity
            let hitWall = false;
            if (currentX < 0 || currentX > width) {
                vx = -vx;
                currentX += vx; // unstuck
                hitWall = true;
            }
            if (currentY < 0 || currentY > height) {
                vy = -vy;
                currentY += vy;
                hitWall = true;
            }

            // 3. Collision / Direction Change Logic
            collisionCountdown--;

            // Change direction if countdown is zero OR we haven't started yet
            if (collisionCountdown <= 0) {
                // Record the turning point (vertex) for the zig-zag line
                // We don't record every pixel, just the corners
                pathVertices.push({x: currentX, y: currentY});
                
                // Pick a new random direction (Random Angle)
                const angle = Math.random() * Math.PI * 2;
                vx = Math.cos(angle) * PARTICLE_SPEED;
                vy = Math.sin(angle) * PARTICLE_SPEED;
                
                // Set time until next collision (longer duration for clear straight lines)
                // Random duration between 40 and 100 steps
                collisionCountdown = Math.floor(Math.random() * 60) + 40;
            }
        }

        function draw() {
            // Clear background
            ctx.fillStyle = "#f8fafc"; 
            ctx.fillRect(0, 0, width, height);

            if (pathVertices.length === 0) return;

            // 1. Draw Start Point (Hollow Green Circle)
            ctx.beginPath();
            ctx.arc(startX, startY, 8, 0, Math.PI * 2);
            ctx.strokeStyle = "#10b981"; // Green
            ctx.lineWidth = 2;
            ctx.stroke();
            // Label Start
            ctx.fillStyle = "#10b981";
            ctx.font = "12px sans-serif";
            ctx.fillText("起點 Start", startX - 25, startY - 15);

            // 2. Draw Zig-Zag Path (Connecting vertices)
            ctx.beginPath();
            ctx.moveTo(pathVertices[0].x, pathVertices[0].y);
            
            // Loop through all recorded collision points
            for (let i = 1; i < pathVertices.length; i++) {
                ctx.lineTo(pathVertices[i].x, pathVertices[i].y);
            }
            // Draw line to current moving head
            ctx.lineTo(currentX, currentY);
            
            ctx.strokeStyle = "#64748b"; // Slate-500
            ctx.lineWidth = 2;
            ctx.lineJoin = "round";
            ctx.stroke();

            // 3. Draw Collision Points (Dots at vertices)
            // This emphasizes the "Zig Zag" nature
            ctx.fillStyle = "#cbd5e1"; // Light slate
            for (let i = 1; i < pathVertices.length; i++) {
                ctx.beginPath();
                ctx.arc(pathVertices[i].x, pathVertices[i].y, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // 4. Draw Displacement Vector (Red Dashed Line)
            ctx.beginPath();
            ctx.setLineDash([6, 6]); 
            ctx.moveTo(startX, startY);
            ctx.lineTo(currentX, currentY);
            ctx.strokeStyle = "#ef4444"; // Red-500
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.setLineDash([]); // Reset dash

            // 5. Draw Current Particle
            ctx.beginPath();
            ctx.arc(currentX, currentY, 12, 0, Math.PI * 2);
            ctx.fillStyle = "#334155"; // Slate-700
            ctx.fill();
            // Inner highlight
            ctx.beginPath();
            ctx.arc(currentX - 3, currentY - 3, 4, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(255,255,255,0.2)";
            ctx.fill();
        }

        function loop() {
            if (!isRunning) return;

            // Steps per frame controlled by slider
            let steps = parseInt(speedSlider.value);
            for(let i=0; i<steps; i++) {
                step();
            }
            
            updateStats();
            draw();
            animationId = requestAnimationFrame(loop);
        }

        // --- Event Listeners ---

        btnToggle.addEventListener('click', () => {
            isRunning = !isRunning;
            if (isRunning) {
                btnToggle.innerText = "暫停 (Pause)";
                btnToggle.classList.remove("bg-blue-600", "hover:bg-blue-700");
                btnToggle.classList.add("bg-amber-500", "hover:bg-amber-600");
                if (collisionCountdown === 0) {
                     // Initial Kickstart
                     step(); 
                }
                loop();
            } else {
                btnToggle.innerText = "繼續 (Resume)";
                btnToggle.classList.remove("bg-amber-500", "hover:bg-amber-600");
                btnToggle.classList.add("bg-blue-600", "hover:bg-blue-700");
                cancelAnimationFrame(animationId);
            }
        });

        btnReset.addEventListener('click', () => {
            isRunning = false;
            cancelAnimationFrame(animationId);
            btnToggle.innerText = "開始 (Start)";
            btnToggle.classList.remove("bg-amber-500", "hover:bg-amber-600");
            btnToggle.classList.add("bg-blue-600", "hover:bg-blue-700");
            reset();
        });

        // Initialize
        resize();
        reset();

    </script>
</body>
</html>
